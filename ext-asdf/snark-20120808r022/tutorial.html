<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD><TITLE></TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -O -fix tutorial.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF section 1 -->




<H1 ALIGN=center>A Guide to <FONT COLOR=navy>SNARK</FONT></H1>

<H3 ALIGN=center>Mark E. Stickel &nbsp;&nbsp;	Richard J. Waldinger &nbsp;&nbsp;Vinay K. Chaudhri </H3>
<!--TOC section Table of Contents-->

<H2>Table of Contents</H2><!--SEC END -->

<UL><LI>
<A HREF="#htoc1">1&nbsp;&nbsp;Preface</A>
<LI><A HREF="#htoc2">2&nbsp;&nbsp;Getting Started</A>
<UL><LI>
<A HREF="#htoc3">2.1&nbsp;&nbsp;<FONT COLOR=navy>SNARK</FONT>  language and theories</A>
<UL><LI>
<A HREF="#htoc4">2.1.1&nbsp;&nbsp;The <FONT COLOR=navy>SNARK</FONT>  language</A>
<LI><A HREF="#htoc5">2.1.2&nbsp;&nbsp;<FONT COLOR=navy>SNARK</FONT>  Theories</A>
<LI><A HREF="#htoc6">2.1.3&nbsp;&nbsp;Clauses</A>
</UL>
<LI><A HREF="#htoc7">2.2&nbsp;&nbsp;Resolution</A>
<LI><A HREF="#htoc8">2.3&nbsp;&nbsp;Invoking <FONT COLOR=navy>SNARK</FONT></A>
<UL>
<UL><LI>
<A HREF="#htoc9">Exercise: Resolution versus Hyperresolution.</A>
</UL>
</UL>
<LI><A HREF="#htoc10">2.4&nbsp;&nbsp;Changing <FONT COLOR=navy>SNARK</FONT>'s Defaults</A>
<LI><A HREF="#htoc11">2.5&nbsp;&nbsp;Basic Answer Extraction</A>
</UL>
<LI><A HREF="#htoc12">3&nbsp;&nbsp;Language and Logic</A>
<UL><LI>
<A HREF="#htoc13">3.1&nbsp;&nbsp;The Syntax of Symbols</A>
<LI><A HREF="#htoc14">3.2&nbsp;&nbsp;Sorts</A>
<UL>
<UL><LI>
<A HREF="#htoc15">Example: Grandmothers.</A>
</UL>
</UL>
<LI><A HREF="#htoc16">3.3&nbsp;&nbsp;Skolemization</A>
<UL>
<UL><LI>
<A HREF="#htoc17">Remark: Quantifier Force.</A>
</UL>
</UL>
<LI><A HREF="#htoc18">3.4&nbsp;&nbsp;Equivalence</A>
<UL>
<UL><LI>
<A HREF="#htoc19">Exercise: In-Laws.</A>
<UL><LI>
<A HREF="#htoc20">Hints.</A>
<LI><A HREF="#htoc21">Solution.</A>
</UL>
</UL>
</UL>
<LI><A HREF="#htoc22">3.5&nbsp;&nbsp;Equality and Paramodulation</A>
<UL>
<UL><LI>
<A HREF="#htoc23">Example: Grandchildren of Alice.</A>
</UL>
</UL>
</UL>
<LI><A HREF="#htoc24">4&nbsp;&nbsp;Answer Management</A>
<UL><LI>
<A HREF="#htoc25">4.1&nbsp;&nbsp;Multiple Answers</A>
<LI><A HREF="#htoc26">4.2&nbsp;&nbsp;Avoiding Duplicate Answers</A>
<LI><A HREF="#htoc27">4.3&nbsp;&nbsp;Constructive Answer Restriction</A>
<UL>
<UL><LI>
<A HREF="#htoc28">Exercise: Riddle.</A>
<UL><LI>
<A HREF="#htoc29">Hint.</A>
<LI><A HREF="#htoc30">Solution.</A>
<LI><A HREF="#htoc31">Remark: Skolem functions in answers.</A>
</UL>
<LI><A HREF="#htoc32">Exercise: Cousins.</A>
<UL><LI>
<A HREF="#htoc33">Solution.</A>
</UL>
</UL>
</UL>
<LI><A HREF="#htoc34">4.4&nbsp;&nbsp;Existentially Quantified Variables in Answers</A>
<LI><A HREF="#htoc35">4.5&nbsp;&nbsp;Conditional Answers</A>
</UL>
<LI><A HREF="#htoc36">5&nbsp;&nbsp;Efficiency Considerations</A>
<UL><LI>
<A HREF="#htoc37">5.1&nbsp;&nbsp;Commutative and Associative Symbols</A>
<LI><A HREF="#htoc38">5.2&nbsp;&nbsp;Set of Support</A>
<LI><A HREF="#htoc39">5.3&nbsp;&nbsp;Recursive-Path Ordering Strategy</A>
<LI><A HREF="#htoc40">5.4&nbsp;&nbsp;Predicate Ordering Strategy</A>
<LI><A HREF="#htoc41">5.5&nbsp;&nbsp;Obtaining Left-to-Right Behavior</A>
<LI><A HREF="#htoc42">5.6&nbsp;&nbsp;Rewrite Rules</A>
<UL><LI>
<A HREF="#htoc43">5.6.1&nbsp;&nbsp;Proceed with Caution</A>
<LI><A HREF="#htoc44">5.6.2&nbsp;&nbsp;Rewrite Rules May Be Introduced Automatically</A>
<UL><LI>
<A HREF="#htoc45">Exercise: Efficiency</A>
</UL>
</UL>
</UL>
<LI><A HREF="#htoc46">6&nbsp;&nbsp;Temporal Reasoning</A>
<UL><LI>
<A HREF="#htoc47">6.1&nbsp;&nbsp;Time Points</A>
<LI><A HREF="#htoc48">6.2&nbsp;&nbsp;Time Intervals</A>
<UL><LI>
<A HREF="#htoc49">6.2.1&nbsp;&nbsp;Allen Primitives</A>
<LI><A HREF="#htoc50">6.2.2&nbsp;&nbsp;Nonprimitive Relations</A>
</UL>
<LI><A HREF="#htoc51">6.3&nbsp;&nbsp;Intermixing Temporal and Relational Reasoning</A>
<LI><A HREF="#htoc52">6.4&nbsp;&nbsp;Mixed Point-Interval Relations</A>
<UL><LI>
<A HREF="#htoc53">6.4.1&nbsp;&nbsp;Point-Interval Relations</A>
<LI><A HREF="#htoc54">6.4.2&nbsp;&nbsp;Interval-Point Relations</A>
<LI><A HREF="#htoc55">6.4.3&nbsp;&nbsp;Nonprimitive mixed relations</A>
</UL>
<LI><A HREF="#htoc56">6.5&nbsp;&nbsp;Temporal Functions</A>
<LI><A HREF="#htoc57">6.6&nbsp;&nbsp;Point-Interval Temporal and Relational Reasoning</A>
<LI><A HREF="#htoc58">6.7&nbsp;&nbsp;Calendar Dates and Clock Times</A>
<LI><A HREF="#htoc59">6.8&nbsp;&nbsp;Dates in Other Time Intervals</A>
<LI><A HREF="#htoc60">6.9&nbsp;&nbsp;Temporal Reasoner Interface</A>
</UL>
<LI><A HREF="#htoc61">7&nbsp;&nbsp;Procedural Attachment</A>
<UL><LI>
<A HREF="#htoc62">7.1&nbsp;&nbsp;Rewrite Code</A>
<UL><LI>
<A HREF="#htoc63">7.1.1&nbsp;&nbsp;Built-in Rewrite Code</A>
<LI><A HREF="#htoc64">7.1.2&nbsp;&nbsp;User-Supplied Rewrite Code</A>
<LI><A HREF="#htoc65">7.1.3&nbsp;&nbsp;Example: Rewrite Code for <TT>mother</TT></A>
</UL>
<LI><A HREF="#htoc66">7.2&nbsp;&nbsp;Satisfy and Falsify Code</A>
<UL><LI>
<A HREF="#htoc67">7.2.1&nbsp;&nbsp;Satisfy Code for mother</A>
<LI><A HREF="#htoc68">7.2.2&nbsp;&nbsp;Falsify code for <TT>mother</TT></A>
</UL>
</UL>
<LI><A HREF="#htoc69">8&nbsp;&nbsp;Support for <FONT COLOR=navy>KIF</FONT>/<FONT COLOR=navy>OKBC</FONT>  Users</A>
<UL><LI>
<A HREF="#htoc70">8.1&nbsp;&nbsp;Introduction to <FONT COLOR=navy>KIF</FONT></A>
<LI><A HREF="#htoc71">8.2&nbsp;&nbsp;Description of <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT></A>
<UL><LI>
<A HREF="#htoc72">8.2.1&nbsp;&nbsp;Declaring Classes</A>
<LI><A HREF="#htoc73">8.2.2&nbsp;&nbsp;Declaring Individuals</A>
<LI><A HREF="#htoc74">8.2.3&nbsp;&nbsp;Declaring Relations</A>
<LI><A HREF="#htoc75">8.2.4&nbsp;&nbsp;Declaring Functions</A>
<LI><A HREF="#htoc76">8.2.5&nbsp;&nbsp;Declaring Assertions</A>
<UL><LI>
<A HREF="#htoc77">Exercise: Uniqueness of Mothers-in-law.</A>
<UL><LI>
<A HREF="#htoc78">Solution.</A>
</UL>
</UL>
</UL>
<LI><A HREF="#htoc79">8.3&nbsp;&nbsp;Relationship of <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  with <FONT COLOR=navy>SNARK</FONT></A>
<LI><A HREF="#htoc80">8.4&nbsp;&nbsp;Built-in Number Sorts</A>
</UL>
</UL>

<!--TOC section Preface-->

<H2><A NAME="htoc1">1</A>&nbsp;&nbsp;Preface</H2><!--SEC END -->

<A NAME="sec-preface"></A>
 <FONT COLOR=navy>SNARK</FONT>, SRI's New Automated Reasoning Kit, is a theorem prover
 intended for applications in artificial intelligence and software
 engineering. <FONT COLOR=navy>SNARK</FONT>  is geared toward dealing with large sets of
 assertions; it can be specialized with strategic controls that tune
 its performance; and it has facilities for integrating
 special-purpose reasoning procedures with general-purpose inference.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  has been used as the reasoning component of SRI's High
 Performance Knowledge Base (HPKB) system, which deduces answers to
 questions based on large repositories of information. It constitutes
 the deductive core of the NASA Amphion system, which composes
 software from components to meet users' specifications, e. g., to
 perform computations in planetary astronomy. <FONT COLOR=navy>SNARK</FONT>  has also been
 connected to Kestrel's <FONT COLOR=navy>SPECWARE</FONT>  environment for software
 development.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  is a resolution-and-paramodulation theorem prover for
first-order logic with equality---in this sense, it is in the same
category as Argonne's <FONT COLOR=navy>OTTER</FONT> ([<CITE><A HREF="#otter">McCune</A></CITE>]).
<FONT COLOR=navy>SNARK</FONT>  has provisions for both clausal and nonclausal reasoning, and
it has an optional sort mechanism. It incorporates associative/commutative
unification and a built-in decision procedure for reasoning about temporal
points and intervals. It has no special facilities for proof by mathematical
induction. It has some capabilities for abductive reasoning, which have been
used in natural-language applications.
<FONT COLOR=navy>SNARK</FONT>  is implemented in an easily portable subset of <FONT COLOR=navy>COMMON LISP</FONT>.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  is a refutation system; in other words, rather that trying to
show directly that some assertions imply a desired conclusion, it attempts to
show that the assertions and the negation of the conclusion imply a
contradiction. It is an agenda-based system; that is, in seeking a
refutation, it will put the assertions and the negation of the conclusion on
an agenda. An agenda is a list of formulas. When a formula reaches the top of
the agenda, <FONT COLOR=navy>SNARK</FONT>  will perform selected inferences involving that formula
and the previously processed formulas. The consequences of those inferences
are added to the agenda. This process continues until the propositional
symbol
<TT>false</TT>  is derived; this means that a contradiction has been deduced
and the refutation is complete. The user has considerable control
over the position at which a newly derived formula is placed on the
agenda; this is one way in which a knowledgeable user can tailor
<FONT COLOR=navy>SNARK</FONT>'s search strategy to a particular application.<BR>
<BR>
This document is an example-driven tutorial introduction to
<FONT COLOR=navy>SNARK</FONT>  that will allow the reader to experiment with the system.
It does not purport to introduce mathematical logic or resolution theorem
proving; [<CITE><A HREF="#chang">Chang</A></CITE>] provides an introduction to this style of theorem
proving that does not assume any prior knowledge of logic. The guide also
uses some notions introduced more fully in [<CITE><A HREF="#manna">Manna</A></CITE>] and
[<CITE><A HREF="#waldinger">Waldinger</A></CITE>], particularly nonclausal resolution, quantifier
force, and answer extraction. Knowledge of <FONT COLOR=navy>LISP</FONT>  syntax and basics
is also assumed here (e. g., see [<CITE><A HREF="#ansi-commonlisp">Graham</A></CITE>] or
[<CITE><A HREF="#commonlisp-hyperspec">Pitman</A></CITE>]). Nevertheless, it is intended that a
reader who is willing to suspend incomprehension will be able to
read this document without consulting other sources.<BR>
<BR>
The guide is divided into several sections. In Getting Started
(Section <A HREF="#sec-getting-started">2</A>) we give the minimum information
necessary to allow a user to get started with <FONT COLOR=navy>SNARK</FONT>. We show how
to enter axioms, and pose questions and set <FONT COLOR=navy>SNARK</FONT> parameters. In
Language and Logic (Section <A HREF="#sec-language-and-logic">3</A>) we introduce
the aspects of the <FONT COLOR=navy>SNARK</FONT>  language, including sorts, equality, and
quantifiers, and we discuss mechanisms for dealing with them,
including the paramodulation rule and skolemization. In Section
<A HREF="#sec-answer-extraction">4</A>, Topics in Answer Extraction, we discuss
how <FONT COLOR=navy>SNARK</FONT>  is used to provide answers to questions (other than a
simple Yes), and how answers are managed. In Efficiency
Considerations (Section
<A HREF="#sec-efficiency-considerations">5</A>) we describe <FONT COLOR=navy>SNARK</FONT>  features that
help us direct the search, to find an answer more quickly.<BR>
<BR>
In Temporal Reasoning (Section <A HREF="#sec-temporal-reasoning">6</A>) we describe the
feature that allows <FONT COLOR=navy>SNARK</FONT>  to reason efficiently about temporal points and
intervals. In Procedural Attachment (Section
<A HREF="#sec-procedural-attachment">7</A>) we talk about how <FONT COLOR=navy>SNARK</FONT>  can do inferences
using special-purpose external procedures supplied by the user. In Support
for <FONT COLOR=navy>KIF</FONT>/<FONT COLOR=navy>OKBC</FONT>  Users (Section <A HREF="#sec-kif-snark">8</A>) we describe
<FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT> (<FONT COLOR=navy>KIF</FONT>  plus Classes), the facility that enables <FONT COLOR=navy>SNARK</FONT>  to
understand assertions and queries phrased in <FONT COLOR=navy>KIF</FONT>, the Knowledge
Interchange Format, with some extensions from <FONT COLOR=navy>OKBC</FONT> (``Open
Knowledge-Base Connectivity''), an object-oriented framework for
representing knowledge. This dialect was used in the HPKB project
and other knowledge representation efforts.<BR>
<BR>
In future versions of this guide we intend to include a description of
<FONT COLOR=navy>SNARK</FONT>'s abduction mechanism, a reference manual, and a description of
<FONT COLOR=navy>SNARK</FONT>'s internal workings. The guide is meant to be a living document, that
will change as <FONT COLOR=navy>SNARK</FONT>  develops.<BR>
<BR>
<A NAME="part-tutorial"></A>
<!--TOC section Getting Started-->

<H2><A NAME="htoc2">2</A>&nbsp;&nbsp;Getting Started</H2><!--SEC END -->

<A NAME="sec-getting-started"></A>
In this section, we give minimum information necessary to get
started with <FONT COLOR=navy>SNARK</FONT>.<BR>
<BR>
<!--TOC subsection <FONT COLOR=navy>SNARK</FONT>  language and theories-->

<H3><A NAME="htoc3">2.1</A>&nbsp;&nbsp;<FONT COLOR=navy>SNARK</FONT>  language and theories</H3><!--SEC END -->

<A NAME="subsec-language-and-theories"></A>
We begin by introducing the language of <FONT COLOR=navy>SNARK</FONT>  and then show how to describe
subject matter as a logical theory. As a running example in this document,
we illustrate of the use of <FONT COLOR=navy>SNARK</FONT>  to reason in a theory of family
relationships.<BR>
<BR>
<!--TOC subsubsection The <FONT COLOR=navy>SNARK</FONT>  language-->

<H4><A NAME="htoc4">2.1.1</A>&nbsp;&nbsp;The <FONT COLOR=navy>SNARK</FONT>  language</H4><!--SEC END -->

<EM>Terms</EM> stand for entities, such as things and people, while <EM>formulas</EM> stand for truth-values, either true or false. <EM>Constants</EM>,
such as <TT>carol</TT> and <EM>variables</EM>, such as
<TT>?x</TT>, are terms. A constant such as <CODE>betty</CODE>
or <CODE>carol</CODE> refers to only one thing, while a variable may refer to
different things, depending on context. (Note that <FONT COLOR=navy>SNARK</FONT>  is usually
case-insensitive; it will not distinguish between the constants
<CODE>carol</CODE>, <CODE>CAROL</CODE>, and <CODE>CaRoL</CODE>.)<BR>
<BR>
Function symbols, such as <CODE>father</CODE> and <CODE>mother</CODE>, can be applied to
a term to yield another term, such as <CODE>(father carol)</CODE> and
<CODE>(mother ?x)</CODE>, standing for the father of Carol and the mother of <TT>?x</TT>,
respectively. Because these function symbols take only one argument, we say
that are <EM>unary</EM>, or of <EM>arity</EM> 1.<BR>
<BR>
Predicate symbols, such as <CODE>parent</CODE> or <CODE>grandparent</CODE>, are applied
to terms but yield <EM>atoms</EM>, which are elementary formulas, not terms.
Thus
<PRE>
  (parent carol ?x)
</PRE>is an atomic formula that stands for a
truth-value, which is true if Carol is indeed a parent of <TT>?x</TT>, and false
otherwise. Predicate symbols stand for a relation between entities;
<CODE>parent</CODE> stands for the parenthood relation. Because <CODE>parent</CODE> and
<CODE>grandparent</CODE> take two arguments, we say they are <EM>binary</EM> predicate
symbols, of arity 2. There are also <EM>propositional</EM> symbols, such as
<TT>it-is-raining</TT>, which are themselves atoms, and can be either true or
false. Finally, there are two special propositional symbols, the <EM>truth
symbols</EM>
<CODE>true</CODE> and <CODE>false</CODE>, which always stand for the truth-values true
and false, respectively.<BR>
<BR>
Other formulas are built up from atoms by successive application of
logical <EM>connectives</EM> (<CODE>and</CODE>, <CODE>or</CODE>, <CODE>not</CODE>,
<CODE>implies</CODE>,
<CODE>implied-by</CODE>, <CODE>iff</CODE>, <TT>xor</TT> <TT>nand</TT>, and <TT>nor</TT>), the <EM>universal quantifier</EM>
<CODE>forall</CODE> and the <EM>existential quantifier</EM> <CODE>exists</CODE>.
Various synonyms are accepted for these symbols.<BR>
<BR>
Thus, if <CODE>&lt;Form1&gt;</CODE> and <CODE>&lt;Form2&gt;</CODE> are formulas, so are
<PRE>
  (and &lt;Form1&gt; &lt;Form2&gt;)

  (exists (?x) &lt;Form1&gt;)
</PRE>and so forth. For example,
<PRE>
  (forall (?x)
   (implies
    (parent ?x (mother carol))
    (grandparent ?x carol)))
</PRE>is a formula, which means that anyone who is a parent of the mother of Carol
is a grandparent of Carol. (In the theory we have in mind, this formula
stands for the truth-value true.) We will say that the occurrences of <TT>?x</TT>
in the above formula are <EM>bound</EM> by the quantifier
<CODE>(forall(?x)...)</CODE>.
Variable occurrences that are not bound by any quantifier are said to be <EM>free</EM>.<BR>
<BR>
Any symbol in the list following a quantifier is taken to be a variable,
whether or not it is prefixed by <CODE>?</CODE>. Thus, the above formula could
just as well have been written
<PRE>
  (forall (x)
   (implies
    (parent x (mother carol))
    (grandparent x carol)))
</PRE>An occurrence of <CODE>x</CODE> not bound by a quantifier is
taken to be a constant, while any symbol prefixed by <CODE>?</CODE> is
automatically a variable, whether or not it is bound by a quantifier;
we call these <EM>?-variables</EM>.<BR>
<BR>
Together, terms and formulas make up the <EM>expressions</EM>. No expression is
both a term and a formula. A string of symbols, such as
<PRE>
  (father (parent ?y carol))
</PRE>obtained by applying a function symbol to a formula is not a legal expression
in the <FONT COLOR=navy>SNARK</FONT>  language.<BR>
<BR>
<!--TOC subsubsection <FONT COLOR=navy>SNARK</FONT>  Theories-->

<H4><A NAME="htoc5">2.1.2</A>&nbsp;&nbsp;<FONT COLOR=navy>SNARK</FONT>  Theories</H4><!--SEC END -->

A <EM>theory</EM>, then is a vocabulary of constant, function, and predicate
symbols, and a set of formulas, called <EM>assertions</EM>, which describe the
properties of the entities mentioned in the theory. For example, in the
family theory we are discussing, we can introduce the assertion
<PRE>
  (parent betty carol)
</PRE>to say that Betty is a parent of Carol.<BR>
<BR>
The fact that fathers and mothers are parents is expressed by the two <FONT COLOR=navy>SNARK</FONT>
assertions
<PRE>
  (forall (?x) (parent (father ?x) ?x))

  (forall (?x) (parent (mother ?x) ?x))
</PRE>In other words, the father of <TT>?x</TT> is a parent of <TT>?x</TT>, and the
mother of <TT>?x</TT> is a parent of <TT>?x</TT>.<BR>
<BR>
There is a convention that, in assertions, free ?-variables <TT>?x</TT>  are actually
bound by an invisible universal quantifier <CODE>(forall (?x)...)</CODE>. Thus, the
above assertions could have been written
<PRE>
  (parent (father ?x) ?x)

  (parent (mother ?x) ?x)
</PRE>Had we used variables without question-marks, however, we could not have
omitted the quantifier <CODE>(forall (x)...)</CODE>; <CODE>x</CODE> would have been taken to
be a constant.<BR>
<BR>
The fact that a parent of a parent is a grandparent is expressed by
the following <FONT COLOR=navy>SNARK</FONT>  assertion:
<PRE>
  (implies
   (and (parent ?x ?y) (parent ?y ?z))
   (grandparent ?x ?z))
</PRE>That is, if ?x is a parent of ?y, and ?y is a parent of ?z, then ?x is
a grandparent of ?z.<BR>
<BR>
Once we have formulated a theory, we can pose a <EM>query</EM>, which is a
<FONT COLOR=navy>SNARK</FONT>  formula treated as a question rather than an assertion.
<FONT COLOR=navy>SNARK</FONT>  will attempt to show that a query follows from all the assertions of
the theory.
For example, if we want to ask if Carol has a grandparent, we may pose the
query
<PRE>
 (exists (?z) (grandparent ?z carol))
</PRE>In other words, we want to deduce that there exists <TT>?z</TT>  such that <TT>?z</TT>
is a grandparent of Carol.<BR>
<BR>
The convention for queries is the opposite of that for assertions. In a
query, a free ?-variable <TT>?z</TT>  is bound by an invisible existential quantifier
<CODE>(exists (?z)...)</CODE>. Thus, the above query could have been written
<PRE>
  (grandparent ?z carol)
</PRE>
In attempting to prove this query, <FONT COLOR=navy>SNARK</FONT>  will assert the negation of the
query and attempt to derive a contradiction from that and the other
assertions. Thus, <FONT COLOR=navy>SNARK</FONT>  will assert
<PRE>
  (not (grandparent ?z carol))
</PRE>and attempt to deduce the truth symbol <CODE>false</CODE>. If it succeeds, we know
that all the assertions together must be contradictory.<BR>
<BR>
<!--TOC subsubsection Clauses-->

<H4><A NAME="htoc6">2.1.3</A>&nbsp;&nbsp;Clauses</H4><!--SEC END -->

<FONT COLOR=navy>SNARK</FONT>  is more efficient
when dealing with formulas in <EM>clausal form.</EM>
A <TT>clause</TT> is a special kind of formula that consists of a
disjunction of <TT>literals</TT>, where each literal is either an atom or
the negation of an atom. For instance, the formula
<PRE>
  (or
   (not (parent ?person ?person1))
   (not (parent ?person1 ?person2))
   (grandparent ?person ?person2))
</PRE>is in clausal form; it is the disjunction (<TT>or</TT>-ing) of three literals:
one atom and two negations of atoms. This clause is equivalent to the
assertion that the parent of a parent is a grandparent. Much resolution
theorem proving is based on the fact that the problem of refuting any formula
is equivalent to one of refuting a formula that is in clausal form, i. e.,
that consists of a conjunction (<TT>and</TT>-ing) of clauses. As its default,
<FONT COLOR=navy>SNARK</FONT>  translates all formulas into clausal form, which it can deal with
most efficiently.<BR>
<BR>
<!--TOC subsection Resolution-->

<H3><A NAME="htoc7">2.2</A>&nbsp;&nbsp;Resolution</H3><!--SEC END -->

<A NAME="subsec-resolution"></A>
In searching for a refutation, <FONT COLOR=navy>SNARK</FONT>  will apply the resolution rule
to the formulas on its agenda. In its simplest form, the rule can be
applied to two given clauses of form
<PRE>
  (or (not P) Q)
</PRE>and
<PRE>
  (or P R)
</PRE>and will deduce the corresponding clause of form
<PRE>
  (or Q R)
</PRE>But the rule is more complex than that. The two given clauses do not
need to have identical subatoms <TT>P</TT>. It is enough if the
subatoms are <EM>unifiable</EM>---in other words, if one can make them
identical by applying a substitution, replacing their
variables by other terms.<BR>
<BR>
The order of the disjuncts is irrelevant; <CODE>(not P)</CODE> and <TT>P</TT>
do not need to be first.
Also it is possible that either or both of the other subformulas <TT>Q</TT> and <TT>R</TT> are actually several disjuncts. Or they may be absent
(i. e., one or both may be taken to be <TT>false</TT>); the given formulas
are then simply <TT>(not P)</TT> or <TT>P</TT>, respectively, and the
deduced formula will then be <TT>R</TT> or <TT>Q</TT>, respectively. If
both <TT>Q</TT> and <TT>R</TT> are absent, the deduced formula is <TT>false</TT>, and the refutation is complete.<BR>
<BR>
We shall see an application of the resolution rule in the following
section.
<!--TOC subsection Invoking <FONT COLOR=navy>SNARK</FONT>-->

<H3><A NAME="htoc8">2.3</A>&nbsp;&nbsp;Invoking <FONT COLOR=navy>SNARK</FONT></H3><!--SEC END -->

<A NAME="subsec-invoking-snark"></A>
Let us see how to invoke <FONT COLOR=navy>SNARK</FONT>  to solve the above problem.<BR>
<BR>
We start with a <FONT COLOR=navy>LISP</FONT>  environment and load the <FONT COLOR=navy>SNARK</FONT>  system; how to
do this depends on your particular installation. We start by typing:
<PRE>
  (initialize)
  (use-resolution t)
</PRE>The <TT>initialize</TT> function will clear out any previous
formulas <FONT COLOR=navy>SNARK</FONT>  has derived and ready it to accept a new theory and
perform a new proof. After initialization, we indicate which
inference rules we would like to use, in this case resolution.<BR>
<BR>
We then introduce the assertions of our theory as <FONT COLOR=navy>SNARK</FONT>  assertions:
<PRE>
  (assert '(parent (father ?x) ?x) :name 'father-is-parent)

  (assert '(parent (mother ?x) ?x) :name 'mother-is-parent)

  (assert
   '(implies
     (and (parent ?x ?y) (parent ?y ?z))
     (grandparent ?x ?z))
   :name 'parent-of-parent-is-grandparent)
</PRE>Note that each assertion is given a name, a string that follows the <EM>keyword</EM> <TT>:name</TT>; these names have no effect on the proof, but will be
used in the trace to indicate where the assertion is used. If the name is
omitted, a number will be used instead. The assertion, its name or number,
and some other information are stored in a structure called a ``row.''<BR>
<BR>
A query is initiated by the <FONT COLOR=navy>SNARK</FONT> <TT>prove</TT> function:
<PRE>
  (prove '(grandparent ?z carol)
          :name 'does-carol-have-a-grandparent)
</PRE>Here we have given the query a name, for our own convenience in
following the proof.<BR>
<BR>
The query has the effect of putting the negation of the formula
<PRE>
  (grandparent ?z carol)
</PRE>into a row and then invoking <FONT COLOR=navy>SNARK</FONT>  to find a refutation.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  will respond by first giving a list of the options that have
been selected. Some of these (e. g., resolution) we have selected;
most of them are defaults:
<PRE>
; The current SNARK option values are
;       (USE-RESOLUTION T)
;       (USE-HYPERRESOLUTION NIL)
; ...
</PRE>This means that we have selected to use resolution and not
hyperresolution. (Hyperresolution is a variant of
resolution that can do several resolution steps at once and is often
more efficient.) <FONT COLOR=navy>SNARK</FONT>  will print out a complete list of the
options it offers, and the settings that have been selected. If the
user has not selected a setting, <FONT COLOR=navy>SNARK</FONT>  will choose the default.
This printing, and the other printing reported here, can be altered by
the user---we are reporting <FONT COLOR=navy>SNARK</FONT>'s default behavior.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  will then print out the assertions it has been given, and the
negation of the conclusion:
<PRE>
(Row father-is-parent
   (parent (father ?x) ?x)
   assertion)
(Row mother-is-parent
   (parent (mother ?x) ?x)
   assertion)
(Row parent-of-parent-is-grandparent
   (or (not (parent ?x ?y)) (not (parent ?y ?z))
       (grandparent ?x ?z))
   assertion)
(Row does-carol-have-a-grandparent
   (not (grandparent ?x carol))
   ~conclusion)
</PRE>
For each row, <FONT COLOR=navy>SNARK</FONT>  provides its name or number, its formula, and an
explanation of its origin. <FONT COLOR=navy>SNARK</FONT>  freely renames variables according
to its own conventions---thus, in the negation of the conclusion, the
variable <TT>?z</TT>  has been renamed <TT>?x</TT>. <FONT COLOR=navy>SNARK</FONT>  provides control
options to suppress the printing of formulas.<BR>
<BR>
Next, <FONT COLOR=navy>SNARK</FONT>  gives an account of the steps it takes in searching for
the proof. If it finds a refutation, it will then reprint only those
rows that play a role.
Here is the first of these steps:
<PRE>
(Row 12
   (or (not (parent ?x ?y))
       (not (parent ?y carol)))
   (resolve does-carol-have-a-grandparent
            parent-of-parent-is-grandparent))
</PRE>Note that the row contains some information about how its formula was
deduced, if it was not an assertion or the negation of the conclusion.
Here Row 12 was obtained by applying the resolution rule to the
negation of the conclusion and the assertion that the parent of a
parent is a grandparent. The unifying substitution replaced the
variable <TT>?z</TT>  with the constant <TT>carol</TT>; this substitution is
reflected in Row 12.<BR>
<BR>
Here is the next step:
<PRE>
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent))
</PRE>Note that the fact that <TT>?x</TT>  occurs in both Row 12 and in the
assertion <TT>father</TT>-<TT>is</TT>-<TT>parent</TT> is not logically
significant---variables are systematically renamed before unification
to avoid such coincidences. Otherwise the two rows would not be
unifiable<BR>
<BR>
Finally, we obtain
<PRE>
(Row 24
   false
   (resolve 23 father-is-parent))
</PRE>The formula <TT>false</TT> indicates that a refution has been obtained.
The intuitive idea behind this proof is that Carol's father is her
parent, Carol's father's father is <EM>his</EM> parent, and, since the
parent of a parent is a grandparent, Carol's father's father is her
grandparent.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  will then report on statistics involved in the proof search,
e.  g.:
<PRE>
; Summary of computation:
;     15 formulas have been input or derived (from 7 formulas).
;     12 (80%) were retained.  Of these,
;         1 ( 8%) were simplified or subsumed later,
;         0 ( 0%) were deleted later because
                  the agenda was full
;        11 (92%) are still being kept.
;
; Run time in seconds excluding printing time:
;      0.01   5%   Resolution
;      0.01   5%   Forward subsumption
;      0.17  89%   Other
;      0.19        Total
; ....
</PRE>To conclude, <FONT COLOR=navy>SNARK</FONT>  will return a value,
<PRE>
:PROOF-FOUND
</PRE>
If the desired conclusion does not follow from the assertions, <FONT COLOR=navy>SNARK</FONT>
will fail to find a proof. There are two ways it may behave in this
case. It may exhaust all possible inferences without finding a
refutation; in this case it will report that the agenda is empty, and
halt, reporting
<PRE>
; All agendas are empty.
:AGENDA-EMPTY
</PRE>Or it may continue to run on indefinitely without ever finding
a refutation.<BR>
<BR>
For instance, if we do not give <FONT COLOR=navy>SNARK</FONT>  the assertion that the parent of a
parent is a grandparent, <FONT COLOR=navy>SNARK</FONT>  will print the two assertions and the
negation of the conclusion, give the statistical summary, and then
halt with an empty agenda.
In this configuration <FONT COLOR=navy>SNARK</FONT>  is a <EM>logically complete</EM> theorem
prover; that is, if conclusion does follow from the assertions,
<FONT COLOR=navy>SNARK</FONT>  will find a proof. Therefore, we know that in this case the
assertions do not imply the conclusion.<BR>
<BR>
On the other hand, if <FONT COLOR=navy>SNARK</FONT>  runs on for longer than we expect, there
is no way, in general, to determine if the conclusion is not valid or
if we simply haven't given it enough time. This is not a particular
weakness of <FONT COLOR=navy>SNARK</FONT>; it is a theoretical limitation on all theorem
provers that are logically complete for first-order logic or more
expressive logics.<BR>
<BR>
If <FONT COLOR=navy>SNARK</FONT>  is running longer than we expect, we may interrupt it by
typing a carriage return at the keyboard. (In most implementations we
may type any character for this purpose.) <FONT COLOR=navy>SNARK</FONT>  will then ask
<PRE>
  Stop now?
</PRE>We may answer <TT>yes</TT>, meaning to interrupt the proof, or <TT>no</TT>,
meaning to continue the proof. Even if we choose to interrupt the
proof, we may continue later by calling the function <CODE>(closure)</CODE>,
the <FONT COLOR=navy>SNARK</FONT>  function that computes the logical consequences of the
current set of rows. This function is also invoked automatically when
we call <TT>prove</TT>. We say more about calling it explicitly in
Section <A HREF="#subsec-multiple-answers">4.1</A>.<BR>
<BR>
Now let us see how to change <FONT COLOR=navy>SNARK</FONT>'s strategies and options.
<A NAME="subsec-select-option"></A><BR>
<BR>
We indicated that <FONT COLOR=navy>SNARK</FONT>  was to use the (binary) resolution rule by
executing
<PRE>
  (use-resolution t)
</PRE>after calling <CODE>initialize</CODE> but before calling
<CODE>prove</CODE>. If we change our mind and decide to try hyperresolution
instead, we can invoke
<PRE>
  (use-resolution nil)
  (use-hyperresolution t)
</PRE>before starting the proof.<BR>
<BR>
<A NAME="clausification"></A>
We have mentioned that clause form is the default for <FONT COLOR=navy>SNARK</FONT>. If we
decided to try using nonclausal resolution instead, we may say
<PRE>
  (use-resolution t)
  (use-clausification nil)
</PRE>after initialization but before beginning the proof. In this case,
<FONT COLOR=navy>SNARK</FONT>  will invoke a nonclausal version of the resolution rule.
(Caution: no nonclausal version of hyperresolution has been
implemented. )<BR>
<BR>
This illustrates a pattern with setting <FONT COLOR=navy>SNARK</FONT>  options.
Henceforth, when we say that we select <FONT COLOR=navy>SNARK</FONT>  option <TT>some-option</TT>, we shall mean that we execute
<PRE>
  (use-some-option t)
</PRE>after initializing <FONT COLOR=navy>SNARK</FONT>  but before beginning the proof. As an
abbreviation, we may simply say
<PRE>
  (use-some-option)
</PRE>to select <TT>some-option</TT>. To turn the option off, we say
<PRE>
  (use-some-option nil)
</PRE>Most of the options that <FONT COLOR=navy>SNARK</FONT>  lists when it begins a proof can be
turned on or off in this manner.<BR>
<BR>
If we want to ask <FONT COLOR=navy>SNARK</FONT>  what its setting is for a particular option
<TT>some-option</TT>,
we may invoke
<PRE>
  (use-some-option?)
</PRE>For instance, if we want to see if <FONT COLOR=navy>SNARK</FONT>  is currently using the
resolution rule, we invoke
<PRE>
  (use-resolution?)
</PRE>
Invoking <TT>initialize</TT> causes <FONT COLOR=navy>SNARK</FONT>  to revert to
its default options. Later (in Section <A HREF="#subsec-change-default">2.4</A>),
we shall see how to change those defaults.<BR>
<BR>
<!--TOC paragraph Exercise: Resolution versus Hyperresolution.-->

<H5>Exercise: Resolution versus Hyperresolution.</H5><!--SEC END -->

Run <FONT COLOR=navy>SNARK</FONT>  on the problem of finding the grandparents of Carol;
compare its performance using resolution and hyperresolution. Also
compare the results using the clausal and the nonclausal versions of
resolution. See what happens if you request the nonclausal
version of hyperresolution, nonexistent at the time of this writing.<BR>
<BR>
The following section, on how to change <FONT COLOR=navy>SNARK</FONT>'s default behavior, may be
omitted on first reading.<BR>
<BR>
<!--TOC subsection Changing <FONT COLOR=navy>SNARK</FONT>'s Defaults-->

<H3><A NAME="htoc10">2.4</A>&nbsp;&nbsp;Changing <FONT COLOR=navy>SNARK</FONT>'s Defaults</H3><!--SEC END -->

<A NAME="subsec-change-default"></A>
Each time we initialize <FONT COLOR=navy>SNARK</FONT>, we restore the setting of all its
options to its defaults. We have seen how, after initialization, we
can reset <FONT COLOR=navy>SNARK</FONT>'s options. This is appropriate if we want to
change <FONT COLOR=navy>SNARK</FONT>'s behavior for a particular query, but want it to
resume its normal behavior subsequently, the next time it is
initialized. If we want a more permanent change, it is convenient to
change <FONT COLOR=navy>SNARK</FONT>'s default behavior; there is a convention about how to go
about this.<BR>
<BR>
Here is an example: as we have seen, use of the resolution rule is not
the default in <FONT COLOR=navy>SNARK</FONT>; if we want to turn it on, we must say
<PRE>
  (use-resolution t)
</PRE>after initializing <FONT COLOR=navy>SNARK</FONT>  and before beginning the proof. Subsequent
calls to <CODE>(initialize)</CODE> will restore the default, i.  e., will turn
resolution back off. If we normally do want to use resolution (as
opposed to hyperresolution, say), we can change <FONT COLOR=navy>SNARK</FONT>'s default; we may
invoke
<PRE>
  (default-use-resolution t)
</PRE>This in itself will not change <FONT COLOR=navy>SNARK</FONT>'s setting on the resolution
option, but subsequent invocation of <TT>initialize</TT> will then turn
on resolution. Thus, typically, we will set the default before we
invoke initialize.<BR>
<BR>
In general, calling
<PRE>
  (default-use-some-option ...)
</PRE>changes the default setting for <TT>some-option</TT>. Calling <TT>initialize</TT>
returns <FONT COLOR=navy>SNARK</FONT>  to its default setting for all options. Calling
<PRE>
  (use-some-option ...)
</PRE>changes the setting for <TT>some-option</TT> temporarily, without changing the
default. Subsequent calls to <TT>initialize</TT> return the setting to
its default again. This enables us to experiment with different
settings for the options without changing the default.<BR>
<BR>
<!--TOC subsection Basic Answer Extraction-->

<H3><A NAME="htoc11">2.5</A>&nbsp;&nbsp;Basic Answer Extraction</H3><!--SEC END -->

<A NAME="subsec-basic-answer-extraction"></A>
In the example of Section <A HREF="#subsec-invoking-snark">2.3</A>, we have
established that Carol has at least one grandparent, but we have not
answered the question ``Who is Carol's grandparent?'' For this
purpose, we may use <FONT COLOR=navy>SNARK</FONT>'s answer-extraction mechanism. We
include in the <TT>prove</TT> statement an indication of what constitutes
an answer, should the proof succeed:
<PRE>
  (prove '(grandparent ?z carol) :answer '(ans ?z))
</PRE>Notice that we have given our query a new component, <EM>the answer
formula</EM>, which follows the keyword <TT>:answer</TT>. This means we are asking
<FONT COLOR=navy>SNARK</FONT> to tell us what value of <TT>?z</TT> will allow us to show that <TT>?z</TT> is
Carol's grandfather. In response, <FONT COLOR=navy>SNARK</FONT> proves the conclusion again,
reporting in each row what substitution was made for <CODE>(ans ?z)</CODE> at that
stage of the proof:
<PRE>
(Refutation
(Row father-is-parent
   (parent (father ?x) ?x)
   assertion)
(Row parent-of-parent-is-grandparent
   (or
    (not (parent ?x ?y))
    (not (parent ?y ?z))
    (grandparent ?x ?z))
   assertion)
(Row does-carol-have-a-grandparent
   (not (grandparent ?x carol))
   ~conclusion
   Answer (ans ?x))
(Row 12
   (or (not (parent ?x ?y)) (not (parent ?y carol)))
   (resolve
     does-carol-have-a-grandparent
     parent-of-parent-is-grandparent)
   Answer (ans ?x))
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent)
   Answer (ans (father ?x)))
(Row 30
     false
     (resolve 23 father-is-parent)
     Answer (ans (father (father carol))))
</PRE>At Row 23, we see that if <TT>?x</TT>  is a parent of Carol, then the father
of <TT>?x</TT>  is a suitable answer (that is, <TT>?x</TT>  is a grandparent of
Carol.) At the end of the proof, we see that the father of the father
of Carol is a grandparent of Carol. Later (Section
<A HREF="#subsec-multiple-answers">4.1</A>), we shall see how to obtain more than
one answer for a given query.<BR>
<BR>
Use of the predicate symbol <TT>ans</TT> is arbitrary; we can give any
formula as the answer formula. We could not, however, say simply
<PRE>
  (prove '(grandparent ?z carol) :answer '?z)
</PRE>because the answer must be a formula, not a term.<BR>
<BR>
This concludes the Getting Started section, which acquaints the user
with the bare minimum necessary to experiment with the system. We now
give a more detailed introduction to <FONT COLOR=navy>SNARK</FONT>.<BR>
<BR>
<!--TOC section Language and Logic-->

<H2><A NAME="htoc12">3</A>&nbsp;&nbsp;Language and Logic</H2><!--SEC END -->

<A NAME="sec-language-and-logic"></A>
In this section we give additional <FONT COLOR=navy>SNARK</FONT>  language constructs and the
mechanisms it has for dealing with these constructs. We include the syntax
of symbols, the
sort mechanism, equivalence, equality, and quantifiers.<BR>
<BR>
<!--TOC subsection The Syntax of Symbols-->

<H3><A NAME="htoc13">3.1</A>&nbsp;&nbsp;The Syntax of Symbols</H3><!--SEC END -->

<A NAME="subsec-symbol-syntax"></A>
The syntax of the basic <FONT COLOR=navy>SNARK</FONT>  symbols can be described as follows.<BR>
<BR>
A <EM>proposition symbol</EM>, <EM>predicate symbol</EM>, or <EM>function symbol</EM>
can be any <FONT COLOR=navy>LISP</FONT>  symbol that
<UL><LI>
is at least one character long,
<LI>does not begin with the character ``<TT>?</TT>'',
<LI>is not the symbol <TT>NIL</TT>,
<LI>is not the (keyword) symbol <TT>:none</TT>, and
<LI>is not another keyword symbol, such as <TT>:name</TT> or <TT>:answer</TT>.
<SUP><A NAME="text1" HREF="#note1">1</A></SUP>
</UL>
A <EM>constant symbol</EM>
can be a <FONT COLOR=navy>LISP</FONT>  number, character, string,
or any <FONT COLOR=navy>LISP</FONT>  symbol that
<UL><LI>
is at least one character long,
<LI>does not begin with the character ``<TT>?</TT>'',
<LI>is not the (keyword) symbol <TT>:none</TT>, and
<LI>is not another keyword symbol.
<SUP><A NAME="text2" HREF="#note2">2</A></SUP>
</UL>
<FONT COLOR=navy>SNARK</FONT>  compares constant symbols using the <FONT COLOR=navy>LISP</FONT>  <TT>EQL</TT> function.
Thus, <TT>3</TT> and <TT>3.0</TT> are different constant symbols.
Ordinarily, <TT>(EQL "ABC" "ABC")</TT> may be false, but <FONT COLOR=navy>SNARK</FONT>  will
use a single copy of string constants so that such tests will succeed.<BR>
<BR>
A <EM>variable symbol</EM>
can be any <FONT COLOR=navy>LISP</FONT>  symbol that
<UL><LI>
is at least two characters long,
<LI>begins with the character ``<TT>?</TT>'', and
<LI>is not a keyword symbol.
</UL>
A variable symbol bound by a quantifier
can also be any <FONT COLOR=navy>LISP</FONT>  symbol that
<UL><LI>
is at least one character long,
<LI>does not begin with the character ``<TT>?</TT>'',
<LI>is not the symbol <TT>NIL</TT>, and
<LI>is not a keyword symbol.
</UL>
Whether <TT>X</TT> is a variable symbol or a constant symbol
depends on whether the occurrence of <TT>X</TT> is bound (or being bound) by
a quantifier or not.<BR>
<BR>
<!--TOC subsection Sorts-->

<H3><A NAME="htoc14">3.2</A>&nbsp;&nbsp;Sorts</H3><!--SEC END -->

<A NAME="subsec-sorts"></A>
Sorts provide a mechanism to restrict the possible instantiations of a
variable in a formula. Sorts can substantially reduce the cost of
inference by restricting the search space. Using sorts some formulas
can be stated more compactly.<BR>
<BR>
In our theory of family relationships, everything is tacitly assumed
to be a person. If an assertion has a global variable <TT>?x</TT>, that
variable is assumed to stand for a person, but that assumption has not
been made explicit.<BR>
<BR>
If we were to combine this theory with another theory of, say,
inanimate objects, we would have to differentiate between those assertions
that are meant to apply to people and those that are meant to apply
to objects. For example, the assertion that says that everyone's father
is his parent holds only for people, not objects.<BR>
<BR>
We could do this by introducing predicate symbols <CODE>person</CODE> and
<CODE>object</CODE>, and augmenting our axioms with antecedents that classify the
variables. For instance, our axiom that fathers are parents could be written
<PRE>
  (assert
   '(implies
     (person ?x)
     (parent (father ?x) ?x))
   :name 'father-is-parent)
</PRE>However, such axioms are more cumbersome to write, particularly if they
 contain many variables. Moreover, including conditions such as
 <CODE>(person ?x)</CODE> makes proofs longer and, consequently, more difficult to
 find. Every time <FONT COLOR=navy>SNARK</FONT>  uses the axiom to prove that a term
<CODE>(father &lt;term&gt;)</CODE> is a parent, it must prove <CODE>(person &lt;term&gt;)</CODE>.<BR>
<BR>
In fact, we might
wish to limit the <TT>parent</TT> and <TT>father</TT> symbols so that their
arguments are forced to be people. We might choose to make it illegal
to write an assertion that mentioned <CODE>(father the-maltese-falcon)</CODE>,
since <TT>the-maltese-falcon</TT> is not a person.<BR>
<BR>
The sort mechanism achieves this by introducing new symbols, called <EM>sorts</EM>, which stand for nonempty sets of entities. The terms of our
vocabulary are classified as being <EM>of</EM> certain sorts.<BR>
<BR>
For instance, we may introduce two new sorts, <TT>person</TT> and
<TT>object</TT>, standing for sets of people and inanimate objects,
respectively, by the declarations
<PRE>
  (declare-sort 'person)
  (declare-sort 'object)
</PRE>If a term is of sort <CODE>person</CODE>, that means that it must stand for a
person.<BR>
<BR>
The intersection of two sorts is assumed to be nonempty unless we deny it
explicitly. For instance, to say that no one is both a person and an object,
we must say
<PRE>
  (declare-disjoint-sorts 'person 'object)
</PRE>(If we make this declaration, we may omit the first two.) Otherwise, <FONT COLOR=navy>SNARK</FONT>
will assume that some entity is both a person and an object.<BR>
<BR>
Let us suppose that we want a richer sort structure; we want to
introduce sorts for men and women as well as people. Then, instead of
(or in addition to) the earlier declaration for <TT>person</TT>, we could
provide
<PRE>
  (declare-subsorts 'person 'man 'woman)
</PRE>This means that <TT>person</TT> has subsorts <TT>man</TT> and <TT>woman</TT>;
every term of sort <TT>man</TT> is also of sort <TT>person</TT>, and
similarly for <TT>woman</TT>.<BR>
<BR>
Finally, if we want to say that <TT>man</TT> and <TT>woman</TT> are a
disjoint partition of <TT>person</TT>, we can say
<PRE>
  (declare-sort-partition 'person 'man 'woman)
</PRE>This means that not only are <TT>man</TT> and <TT>woman</TT> disjoint
subsorts of <TT>person</TT>, but also that every term of sort <TT>person</TT> must be either of sort <TT>man</TT> or of sort <TT>woman</TT>.<BR>
<BR>
It is also possible to use boolean operators to define new sorts or to
express relationships between sorts. For example, if we want to
introduce a new sort that includes objects and men, we can say
<PRE>
  (declare-sort 'object-or-man :iff '(or object man))
</PRE>This means that every term of sort <TT>object-or-man</TT> is of sort <TT>object</TT> or of sort <TT>man</TT>, and every term that is of one of these
two sorts is also of sort <TT>object-or-man</TT>.
Other boolean operators, such as <TT>and</TT> and <TT>not</TT>, may also be
used. <FONT COLOR=navy>SNARK</FONT>  is able to deduce relationships between sorts declared
in this way. For instance, it will know that the sort <TT>object-or-man</TT> is the same as the sort <TT>same-sort</TT> declared by
<PRE>
  (declare-sort 'same-sort
                :iff '(and (or object person) (not woman)))
</PRE>In this way, <FONT COLOR=navy>SNARK</FONT>'s sort mechanism is unusually versatile.<BR>
<BR>
Once we have established a sort structure, we can classify our
vocabulary accordingly. For instance, we can declare Bob to be a man,
Carol to be a woman, and the-maltese-falcon to be an object:
<PRE>
  (declare-constant-symbol 'bob :sort 'man)
  (declare-constant-symbol 'carol :sort 'woman)
  (declare-constant-symbol 'the-maltese-falcon :sort 'object)
</PRE>Here <TT>declare-constant-symbol</TT> is a <FONT COLOR=navy>LISP</FONT>  function whose
value is the declared symbol.<BR>
<BR>
Because we have declared that <TT>man</TT> and <TT>woman</TT> are
disjoint sorts, this also means that <TT>bob</TT> is not of sort <TT>woman</TT> and <TT>carol</TT> is not of sort <TT>man</TT>. Because both <TT>man</TT> and <TT>woman</TT> are subsorts of <TT>person</TT>, and because we have
declared that <TT>person</TT> and <TT>object</TT> are disjoint, this means
further that neither <TT>bob</TT> nor <TT>carol</TT> can be of sort <TT>object</TT>.<BR>
<BR>
We can declare the function symbol <TT>father</TT> to take a person as an
argument and yield a man as a value, as follows:
<PRE>
  (declare-function-symbol 'father 1 :sort '(man person))
</PRE>Note that for the declaration of a function, the sort for the value of the
function comes before the sorts of its arguments. This declaration must be
made before we use the symbol <TT>father</TT> in an assertion or conclusion.
Also, it is required to include the number of arguments (arity) <TT>1</TT> in
the declaration, because if <TT>father</TT> is sometimes used with more than one
argument, those occurrences stand for different functions. A separate
declaration could be given for a two-argument symbol <TT>father</TT>, with
different sorts for its arguments.<BR>
<BR>
If we want to give a function or relation an alternative name, we use the
<EM>alias</EM> mechanism. For instance, we can give the one-argument function
<TT>father</TT> the alternative name <TT>father-1</TT> by providing a declaration
<PRE>
  (declare-function-symbol 'father 1 :sort '(man person)
    :alias 'father-1)
</PRE>Then we can use the name <TT>father-1</TT> when we need to refer unambiguously
to the one-argument father. The two-argument <TT>father</TT> could be given the
alias <TT>father-2</TT>. Usually, however, we do not need to distinguish
between them because <FONT COLOR=navy>SNARK</FONT>  can see how many arguments are provided.
In the trace of the proof, both functions will be represented as <TT>father</TT>.<BR>
<BR>
The fact that the predicate symbol <TT>parent</TT> takes two arguments of
sort <TT>person</TT> is expressed in its declaration:
<PRE>
  (declare-predicate-symbol 'parent 2
    :sort '(boolean person person))
</PRE>Note that predicate symbols are declared as if they were function
symbols that return a value of sort <TT>boolean</TT>.<BR>
<BR>
It is also possible to declare the sorts of variables, such as
<PRE>
  (declare-variable-symbol '?some-guy :sort 'man)
</PRE>If an assertion or query contains free (unquantified) occurrences of the
variable <CODE>?some-guy</CODE>, they will then automatically be of sort
<CODE>man</CODE>.<BR>
<BR>
If a formula contains explicit quantifiers, we can declare the sort of a
variable within the quantifier itself. For example, in a formula
<PRE>
  (forall ((?this-man :sort man)
        (?that-man :sort man)) ...)
</PRE>the variables <CODE>?this-man</CODE> and <CODE>?that-man</CODE> are of sort <CODE>man</CODE>.<BR>
<BR>
Symbols such as <TT>?man</TT>, <TT>?man1</TT>, ..., are automatically
variables of sort <TT>man</TT>. It is illegal to define certain symbols,
such as <TT>u</TT>, ..., <TT>z</TT>, <TT>?u</TT>, ..., or <TT>?z</TT>,
perhaps followed by any number of digits, as sorted variables; by
convention, these are reserved to be unsorted.<BR>
<BR>
The syntax of sorts can be described more exactly as follows:<BR>
<BR>
A <EM>sort symbol</EM>
can be any <FONT COLOR=navy>LISP</FONT>  symbol that
<UL><LI>
is at least two characters long,
<LI>does not begin with the character ``<TT>?</TT>,
<LI>is not the symbol <TT>NIL</TT>,
<LI>is not the (keyword) symbol <TT>:none</TT>, and
<LI>is not a keyword symbol.
<SUP><A NAME="text3" HREF="#note3">3</A></SUP>
<EM>TRUE</EM> and <EM>FALSE</EM> are predefined as the topmost
bottommost sorts.
</UL>
It is permissible to intermix sorted and unsorted symbols; unsorted
terms are implicitly of sort <TT>true</TT>, and every sort is a subsort
of <TT>true</TT>. Thus the unsorted version of <FONT COLOR=navy>SNARK</FONT>  can be regarded
as a special case of the sorted version.<BR>
<BR>
Once a sort structure has been declared, it becomes illegal to apply a
function or a predicate symbol to a term whose argument is of an
unsuitable sort. Thus <FONT COLOR=navy>SNARK</FONT>  will give an error if we say
<PRE>
  (parent the-maltese-falcon bob)
</PRE>because <TT>parent</TT> takes arguments of sort <TT>person</TT>, and <TT>the-maltese-falcon</TT> is not of sort <TT>person</TT>.<BR>
<BR>
Thus, the sort mechanism serves as a debugging aid. In a sorted
theory, many errors in formulating assertions and queries show up as
sort errors, and are easily detected. Without the sort mechanism,
some of these conceptual errors would only become evident when <FONT COLOR=navy>SNARK</FONT>
failed to find a proof; when that happens, it is difficult to decide
which assertion contains the error that is the cause of the failure.<BR>
<BR>
A more important effect of the sort structure is that it limits the
application of resolution and other inference rules. <FONT COLOR=navy>SNARK</FONT>  will
never allow two terms to be unified if their sorts are incompatible.
For example, the variable <TT>?person1</TT> may be unified with a
constant <TT>carol</TT> of sort <TT>woman</TT>, because <TT>woman</TT> is a
subsort of <TT>person</TT>---we can always take <TT>?person1</TT> to stand
for a woman. But a variable <TT>?woman1</TT> may not be unified with a
constant <TT>the-president</TT> of sort <TT>person</TT>, because we cannot
be certain that <TT>the-president</TT> is a woman.<BR>
<BR>
Two variables of different sorts can be unified if we have not
declared the sorts to be disjoint---the unified variable will have as
its sort the conjunction of the two original sorts. A variable <TT>?man1</TT> cannot be unified with a variable <TT>?woman2</TT>, because we
have declared the sorts <TT>man</TT> and <TT>woman</TT> to be disjoint; no
one can be both a man and a woman. But a variable <TT>?person1</TT> can
be unified with a variable <TT>?man2</TT> and vice versa; the unified
variable will be of sort <TT>man</TT>. <FONT COLOR=navy>SNARK</FONT>  will block application of
resolution, paramodulation, and other rules if they violate these
restrictions.<BR>
<BR>
The sort mechanism gives us abbreviated ways of saying things about
subsets of our universe of discourse. For example, we can
introduce an assertion
<PRE>
  (assert '(not (brother ?woman ?person))
   :name 'women-are-not-brothers)
</PRE>to mean that a women cannot be the brother of any person. As we indicated
earlier, if we had no sort
mechanism, we would be forced to write this in terms of predicate symbols, as
<PRE>
  (assert
   '(implies
     (and (woman ?x) (person ?y))
     (not (brother ?x ?y)))
   :name 'women-are-not-brothers)
</PRE>The restrictions on unification makes <FONT COLOR=navy>SNARK</FONT>  behave as if the
conditions <CODE>(woman ?x)</CODE> and <CODE>(person ?y)</CODE> were actually
there, when they are not.<BR>
<BR>
Not only is the latter form of assertion more cumbersome to write, but
also it is less efficient for <FONT COLOR=navy>SNARK</FONT>. The sort mechanism allows us
to make in one step an inference that would require several steps if
people and women were represented by predicate symbols.<BR>
<BR>
Furthermore, the version of <TT>women-are-not-brothers</TT> with sorts is
a unit assertion---it has no connectives. Unit clauses have a
beneficial effect on the search space. In particular, applying the
resolution rule to a unit and a formula yields a smaller formula;
applying the resolution rule to a nonunit and a formula may yield a
larger formula, and produce a correspondingly larger search space.<BR>
<BR>
In declaring a sort structure, we are saying what expressions in the
language are meaningful, not what expressions are true. For instance,
we did not declare the predicate symbol <TT>brother</TT> with the sort
declaration
<PRE>
  (declare-predicate-symbol 'brother 2
    :sort '(boolean man person))
</PRE>Even though we expected that someone's brother will always be a man, we
did not want to exclude from the language formulas in which the first
argument of <TT>brother</TT> is of sort <TT>woman</TT>; otherwise, we would
have had no way of saying that the expression <CODE>(brother betty bob)</CODE>
is false. Merely being false is not the same as being meaningless.
We declared <TT>brother</TT> on sorts for which the brother
relationship is meaningful. If we had wanted to exclude such expressions
from the language, we could have chosen the latter declaration and insisted
that the first argument be a man.<BR>
<BR>
Note that there is no way to include in an assertion the explicit
condition that something is of a particular sort, or that it is not of
a particular sort. For instance, we cannot say something like
<PRE>
  (implies
   (brother ?person1 ?person2)
   ``?person1 is of sort man'')
</PRE>in the <FONT COLOR=navy>SNARK</FONT>  language.
In choosing to represent gender as a sort, we have decided that we
will know in advance whether a person is male or female, and it won't
be necessary to deduce such things.<BR>
<BR>
Note that is it permissible to use the same symbol to stand for a sort and a
predicate symbol; however, <FONT COLOR=navy>SNARK</FONT>  will regard that as a coincidence; it will
not ensure that there is any relationship between the meanings of the two
symbols. (<FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>, the <FONT COLOR=navy>KIF</FONT>-<FONT COLOR=navy>OKBC</FONT> dialect of <FONT COLOR=navy>SNARK</FONT>, described
in Section
<A HREF="#sec-kif-snark">8</A>, does enforce a relationship between sorts and predicate
symbols of the same name.)<BR>
<BR>
<!--TOC paragraph Example: Grandmothers.-->

<H5>Example: Grandmothers.</H5><!--SEC END -->

<A NAME="example-grandmothers"></A> In Section
<A HREF="#subsec-basic-answer-extraction">2.5</A>, we showed how to find a
grandparent of Carol. Suppose we would like to find a grandmother of
Carol, not just any grandparent. Assume we have introduced sorts <TT>man</TT> and <TT>woman</TT> and have declared the sorts for <TT>father</TT> and
<TT>mother</TT> accordingly, so that they yield people of sorts <TT>man</TT>
and <TT>woman</TT> respectively. Then we may pose the query
<PRE>
  (prove '(grandparent ?woman carol) :answer '(ans ?woman))
</PRE>In other words, we are asking for a person of sort <TT>woman</TT> who is
a grandparent of Carol. We will then obtain an answer, either
<CODE>(mother (father carol))</CODE> or <CODE>(mother (mother carol))</CODE>,
depending on which proof is found first. (In Section
<A HREF="#subsec-multiple-answers">4.1</A>, we shall see how to obtain more than
one answer to such queries.)<BR>
<BR>
<!--TOC subsection Skolemization-->

<H3><A NAME="htoc16">3.3</A>&nbsp;&nbsp;Skolemization</H3><!--SEC END -->

<A NAME="subsec-skolemization"></A>
If a formula contains explicit quantifiers, <FONT COLOR=navy>SNARK</FONT>
will remove the quantifiers by skolemization. In particular,
existentially quantified variables in assertions will be replaced by
functional terms, where the function is a newly introduced <EM>skolem
function</EM> or <EM>skolem constant</EM>. We shall call the entire
functional term a <EM>skolem term</EM>. Universal quantifiers will be
removed too, but their variables will remain variables. (Actually, whether a
quantifier is treated as universal or existential depends on whether it
appears within a negation in the assertion---see the remark on Quantifier
Force on Page <A HREF="#subsec-quantifier-force">??</A>).<BR>
<BR>
For example, in Section <A HREF="#subsec-language-and-theories">2.1</A> we introduced an
assertion, later called <TT>parent</TT>-<TT>of</TT>-<TT>parent</TT>-<TT>is</TT>-<TT>grandparent</TT>, that said that any parent of a parent is a
grandparent. Suppose now we need to state the converse, that any grandparent
is the parent of a parent. Then we may formulate this assertion in terms of
an explicit existential quantifier, as (in the sorted theory)
<PRE>
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (exists (?person)
             (and
              (parent ?person1 ?person)
              (parent ?person ?person2))))
   :name 'grandparent-is-parent-of-parent)
</PRE>Note that we cannot omit the existential quantifier, because
unquantified variables have tacit universal quantification. If the
quantifier were missing, we would be saying that every grandparent is a
parent of every person, and that every person is in turn the parent of
the grandchild.<BR>
<BR>
The new assertion will be translated by <FONT COLOR=navy>SNARK</FONT>  (if we turn off the
clausification option, Section <A HREF="#clausification">2.3</A>) into
<PRE>
(Row grandparent-is-parent-of-parent
   (implies
    (grandparent ?person1 ?person2)
    (and (parent ?person1 (#:person-sk1 ?person1 ?person2))
         (parent (#:person-sk1 ?person1 ?person2) ?person2)))
   assertion)
</PRE>Here <CODE>#:person-sk1</CODE> is the skolem function <FONT COLOR=navy>SNARK</FONT>  introduced in
replacing the existential quantifier. Intuitively speaking, if <TT>?person1</TT> is a grandparent of <TT>?person2</TT>, then
<PRE>
  (#:person-sk1 ?person1 ?person2)
</PRE>is the child of <TT>?person1</TT> who is a parent of <TT>?person2</TT>.
Skolem function symbols are prefixed by the sort of the variable whose
quantifier is being removed---in this case <TT>person</TT>. Note again
that <FONT COLOR=navy>SNARK</FONT>  renames the variables in a row as it sees fit.<BR>
<BR>
Note that, instead of using an explicit existential quantifier, we
could have phrased the assertion as follows:
<PRE>
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (and (parent ?person1 (link ?person1 ?person2))
          (parent (link ?person1 ?person2) ?person2)))
          :name 'grandparent-is-parent-of-parent)
</PRE>Here <TT>link</TT> is our own name for the skolem function that <FONT COLOR=navy>SNARK</FONT>
introduced automatically. This formulation may be more mnemonic---the
link is the person who connects a grandparent and grandchild in the
family tree (either the grandchild's mother or father). Also, we are
free to use the function <TT>link</TT> in other assertions and queries,
if we so choose.<BR>
<BR>
It is possible to provide <FONT COLOR=navy>SNARK</FONT>  with a name to use when it
skolemizes a quantifier, using the keyword <TT>conc-name</TT> in the
quantifier, as follows:
<PRE>
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (exists ((?person :conc-name link))
             (and
              (parent ?person1 ?person)
              (parent ?person ?person2))))
   :name 'grandparent-is-parent-of-parent)
</PRE>(Note that the double parentheses in the list of quantified variables
are required; otherwise, <FONT COLOR=navy>SNARK</FONT>  will expect <TT>:conc-name</TT> and <TT>link</TT> to be additional variables of the quantifier and report an
error.) This formula will be skolemized (assuming clausification is
turned off) as
<PRE>
(Row grandparent-is-parent-of-parent
   (implies
    (grandparent ?person ?person1)
    (and
     (parent ?person (#:link1 ?person ?person1))
     (parent (#:link1 ?person ?person1) ?person1)))
   assertion)
</PRE>Here <FONT COLOR=navy>SNARK</FONT>  has not used the exact name we have provided, but it has
 incorporated the string <TT>link</TT> into the name
<CODE>#:link1</CODE> it has constructed.
 This is because <FONT COLOR=navy>SNARK</FONT>  needs to invent a unique symbol every time it
 constructs a skolem function.
 If we gave the same conc-name <TT>link</TT> to another quantifier as
 well, <FONT COLOR=navy>SNARK</FONT>  would invent a different skolem function symbol for the new
 quantifier, but both symbols would incorporate the string <TT>link</TT>.<BR>
<BR>
If an existential quantifier to be removed is within the scope of some
 universal quantifiers, the new skolem function will have arguments---the
 variables of those quantifiers. (We include the invisible quantifiers that
 bind the free variables of the assertion.) Otherwise, we introduce skolem
 constants, not skolem functions. For example, if we introduce the assertion
<PRE>
  (assert
   '(exists (?person) (parent betty ?person))
   :name 'betty-has-a-child)
</PRE><FONT COLOR=navy>SNARK</FONT>  will transform this into the assertion
<PRE>
(Row betty-has-a-child
   (parent betty #:person-sk9)
   assertion)
</PRE>Here <FONT COLOR=navy>SNARK</FONT>  has made up its own name, the skolem constant
 <CODE>#:person-sk9</CODE>, for Betty's child.<BR>
<BR>
<!--TOC paragraph Remark: Quantifier Force.-->

<H5>Remark: Quantifier Force.</H5><!--SEC END -->

<A NAME="subsec-quantifier-force"></A>
If an existential quantifier is within the scope of a single negation, it
will behave as a universal quantifier and will be treated accordingly. In
particular, during skolemization, its variables will remain as variables.
This happens even if the negation is only implicit, when the quantifier is in
a query or in the antecedent of an implication, say. A quantifier that
behaves as a universal, even if it is syntactically an existential, is said
to have <EM>universal force</EM>.<BR>
<BR>
Similarly, it can happen that a universal quantifier will have <EM>existential force</EM> if it is within the scope of a single explicit or
implicit negation---in this case, its variable will be replaced by a
skolem term during skolemization.<BR>
<BR>
Thus, the way quantifiers are treated in queries is precisely the
reverse of the way they are treated in assertions---universally
quantified variables are replaced by skolem terms, while existentially
quantified variables remain variables when quantifiers are removed.
Additional negations reverse the force of the quantifiers yet again; thus,
an existential quantifier that is within the scope of precisely two explicit
or implicit negations does have existential force.<BR>
<BR>
The skolemization procedure is justified by showing that a set of rows
is contradictory precisely when the skolemized version of those rows
is contradictory.
<!--TOC subsection Equivalence-->

<H3><A NAME="htoc18">3.4</A>&nbsp;&nbsp;Equivalence</H3><!--SEC END -->

<A NAME="subsec-equivalence"></A>
We could have combined the two assertions that
defined the notion of a grandparent into a single <FONT COLOR=navy>SNARK</FONT>  assertion using
equivalence, as follows:
<PRE>
  (assert '(iff
            (grandparent ?person1 ?person2)
            (exists (?person)
                    (and (parent ?person1 ?person)
                         (parent ?person ?person2))))
          :name 'grandparent-iff-parent-of-parent)
</PRE><FONT COLOR=navy>SNARK</FONT>  will break this down into two implications; if clausification
has not been turned off, these will then be transformed into clauses.<BR>
<BR>
<!--TOC paragraph Exercise: In-Laws.-->

<H5>Exercise: In-Laws.</H5><!--SEC END -->

<A NAME="exer-in-laws"></A>
In a sorted theory of families, introduce predicate symbols for the
relationships <TT>siblings</TT>, <TT>sister</TT>, <TT>brother</TT>, <TT>spouse</TT>, <TT>wife</TT>, <TT>husband</TT>, <TT>sister-in-law</TT>, and <TT>brother-in-law</TT>. Introduce assertions that relate these notions to each
other. Prove that if a man is a woman's brother-in-law, she is his
sister-in-law. (In other words, the <TT>brother-in-law</TT> and <TT>sister-in-law</TT> relations are <EM>inverses</EM>.)
<!--TOC subparagraph Hints.-->

<H5>Hints.</H5><!--SEC END -->
 A man is a brother-in-law to another person if
he is husband to a sibling of that person, or if he is brother to a
spouse of that person. Similarly for sister-in-law.<BR>
<BR>
You may introduce assertions to express the following facts:
<UL><LI> A husband is a spouse; a wife is a spouse.<BR>
<BR>
<LI> A male spouse is a husband; a female spouse is a wife.<BR>
<BR>
<LI> A brother is a sibling; a sister is a sibling.<BR>
<BR>
<LI> A male sibling is a brother; a female sibling is a sister.</UL>
<!--TOC subparagraph Solution.-->

<H5>Solution.</H5><!--SEC END -->
 The brother-in-law relation is defined by the
assertion
<PRE>
  (assert
   '(iff
     (brother-in-law ?person1 ?person2)
     (or
      (exists (?person)
              (and (husband ?person1 ?person)
                   (sibling ?person ?person2)))
      (exists (?person)
              (and (brother ?person1 ?person)
                   (spouse ?person ?person2)))))
   :name 'brother-in-law)
</PRE>The definition of <TT>sister</TT>-<TT>in</TT>-<TT>law</TT> is analogous.
<BR>
<BR>
The problem is stated as follows:
<PRE>
  (prove
   '(forall (?man ?woman)
         (implies
          (brother-in-law ?man ?woman)
          (sister-in-law ?woman ?man)))
   :name 'brother-and-sister-in-law-are-inverses)
</PRE>Note that we cannot omit the universal quantifier <TT>(forall (?man
?woman) ...)</TT> here, because then the query would be treated as if it were
surrounded by an invisible existential quantifier
<CODE>(exists (?man ?woman)...)</CODE>, which would change its meaning.<BR>
<BR>
The fact that all husbands are spouses is expressed by the assertion
<PRE>
  (assert
   '(implies (husband ?person1 ?person2)
             (spouse ?person1 ?person2))
   :name 'husbands-are-spouses)
</PRE>
The fact that male spouses are husbands is expressed by the assertion
<PRE>
  (assert
   '(iff (spouse ?man ?person)
         (husband ?man ?person))
   :name 'male-spouses-are-husbands)
</PRE>Similar assertions apply to wives, and to
brothers, sisters, and siblings. There are other assertions that
could be made (e.  g., the definition of <TT>sibling</TT>), but they are
not necessary to solve this problem.<BR>
<BR>
<!--TOC subsection Equality and Paramodulation-->

<H3><A NAME="htoc22">3.5</A>&nbsp;&nbsp;Equality and Paramodulation</H3><!--SEC END -->

<A NAME="subsec-equality-and-paramodulation"></A>
The equality relation <CODE>(= ?x ?y)</CODE> means that <TT>?x</TT>  and <TT>?y</TT>
stand for the same thing.<BR>
<BR>
Although it is possible to describe the equality relation by giving
its axioms as <FONT COLOR=navy>SNARK</FONT>  assertions, if we want to reason about the
relation it is usually best to include the paramodulation rule among
our rules of inference. The rule allows us to replace equals with
equals. In its simplest form, the rule can be applied to two clauses
of form
<PRE>
  (or P[s])
</PRE>and
<PRE>
  (or (= s t) Q)
</PRE>where <TT>s</TT> and <TT>t</TT> are terms and the clause <CODE>(or P[s])</CODE>
 contains at least one occurrence of <TT>s</TT>. Then the paramodulation
 rule will deduce the corresponding clause of form
<PRE>
  (or P[t] Q)
</PRE>where the literals <CODE>P[t]</CODE> are obtained from the literals
 <CODE>P[s]</CODE> by replacing all occurrences of <TT>s</TT> with <TT>t</TT>.
 The roles of <TT>s</TT> and <TT>t</TT> may be reversed, so that the rule
 is applied right to left to replace occurrences of <TT>t</TT> with
 <TT>s</TT>. As with the resolution rule, the order of literals is not
 meaningful, and the replaced terms need not be identical to <TT>s</TT>
 or <TT>t</TT>, but merely unifiable.<BR>
<BR>
We can include paramodulation in our arsenal by selecting the option
<TT>use-paramodulation</TT>.
Then no axioms for equality need be provided by the user.<BR>
<BR>
Let us look at an example of the application of the paramodulation
rule.<BR>
<BR>
<!--TOC paragraph Example: Grandchildren of Alice.-->

<H5>Example: Grandchildren of Alice.</H5><!--SEC END -->

<A NAME="example-grandchildren-of-alice"></A>
Suppose we wish to tell <FONT COLOR=navy>SNARK</FONT>  that Carol's mother is
Betty and Betty's mother is Alice; then we may add the new assertions
<PRE>
  (assert '(= (mother carol) betty))

  (assert '(= (mother betty) alice))
</PRE>We assume that we have previously declared <TT>alice</TT>, <TT>betty</TT>,
and <TT>carol</TT> to be constants of sort <TT>woman</TT>, and <TT>mother</TT>
to be a function that takes a <TT>person</TT> into a <TT>woman</TT>.<BR>
<BR>
If we then want to ask who is a grandchild of Alice, we may invoke
<FONT COLOR=navy>SNARK</FONT>  with the query
<PRE>
  (prove '(grandparent alice ?person) :answer '(ans ?person))
</PRE>
If paramodulation has been selected, <FONT COLOR=navy>SNARK</FONT>  will complete the proof
with the answer <TT>carol</TT>. Here is the entire refutation:
<PRE>
(Refutation
(Row mother-is-parent
   (parent (mother ?person) ?person)
   assertion)
(Row mother-of-carol-is-betty
   (= (mother carol) betty)
   assertion)
(Row mother-of-betty-is-alice
   (= (mother betty) alice)
   assertion)
(Row who-is-the-grandchild-of-alice?
   (not (grandparent alice ?person))
   ~conclusion
   Answer (ans ?person))
(Row grandparent-iff-parent-of-parent-39
   (or (not (parent ?person ?person1))
       (not (parent ?person1 ?person2))
       (grandparent ?person ?person2))
   assertion)
(Row 42
   (parent betty carol)
   (paramodulate mother-is-parent mother-of-carol-is-betty))
(Row 43
   (parent alice betty)
   (paramodulate mother-is-parent mother-of-betty-is-alice))
(Row 90
   (or (not (parent alice ?person))
       (not (parent ?person ?person1)))
   (resolve who-is-the-grandchild-of-alice?
     grandparent-iff-parent-of-parent-39)
   Answer (ans ?person1))
(Row 277
   false
   (rewrite (resolve 90 42) 43)
   Answer (ans carol))
)
</PRE>The derivations of Rows 42 and 43 illustrate the use of
paramodulation. For instance, Row 42 has been obtained by applying
paramodulation to the assertion that a mother is a parent,
<PRE>
  (parent (mother ?person) ?person)
</PRE>and the assertion that the mother of Carol is Betty,
<PRE>
  (= (mother carol) betty)
</PRE>The variable <TT>?person</TT> has been unified with <TT>carol</TT>.<BR>
<BR>
The final step, which actually combines two
resolution steps, will be explained in a later discussion on rewrite
rules (Section <A HREF="#subsubsec-rewrite-automatic">5.6.2</A>).<BR>
<BR>
<!--TOC section Answer Management-->

<H2><A NAME="htoc24">4</A>&nbsp;&nbsp;Answer Management</H2><!--SEC END -->

<A NAME="sec-answer-extraction"></A>
We have seen (in Section <A HREF="#subsec-basic-answer-extraction">2.5</A>) how
answers to queries may be extracted from proofs. In this section, we
consider some of the nuances of answer extraction---how to obtain
multiple answers and conditional answers, and how to restrict <FONT COLOR=navy>SNARK</FONT>
to avoid unwanted answers.<BR>
<BR>
<!--TOC subsection Multiple Answers-->

<H3><A NAME="htoc25">4.1</A>&nbsp;&nbsp;Multiple Answers</H3><!--SEC END -->

<A NAME="subsec-multiple-answers"></A>
In Section <A HREF="#subsec-basic-answer-extraction">2.5</A> we saw how to use
<FONT COLOR=navy>SNARK</FONT>  to answer the query ``Who is Carol's grandfather?'' obtaining
a single answer, such as
<PRE>
  (father (father carol))
</PRE>Of course, Carol has more than one grandparent. To find the others,
we may reinvoke <FONT COLOR=navy>SNARK</FONT>  to find a different proof. For this purpose,
we execute the function
<PRE>
  (closure)
</PRE>This is the function that computes computes logical consequences of
the current set of rows, stopping when <FONT COLOR=navy>SNARK</FONT>  finds a new proof. In
calling <TT>prove</TT>, we have implicitly been invoking <TT>closure</TT> on
the initial set of rows. If we call <TT>closure</TT> after a proof has
been interrupted, it will pick up where it left off and try to complete
the proof, as we mentioned in Section <A HREF="#subsec-invoking-snark">2.3</A>.
But if we call <TT>closure</TT> after a proof has been completed, <FONT COLOR=navy>SNARK</FONT>
will try to find a different proof.<BR>
<BR>
Since the example was introduced in the unsorted version of the family
theory, we continue in that version here. <FONT COLOR=navy>SNARK</FONT>  finds a second
proof, which differs from the first only at the last step:
<PRE>
(Refutation
 ...
(Row mother-is-parent
   (parent (mother ?x) ?x)
   assertion)
 ...
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent)
   Answer (ans (father ?x)))
(Row 31
   false
   (resolve 23 mother-is-parent)
   Answer (ans (father (mother carol))))
)
</PRE>In the last step, we have used the assertion that a mother is a
parent---in the first proof, we used the assertion that a father is a
parent instead.<BR>
<BR>
This new proof gives us a different answer: the father of the mother
of Carol. Repeated invocation of <FONT COLOR=navy>SNARK</FONT>  via <TT>closure</TT> gives
another two answers: <CODE>(mother (father carol))</CODE> and
<CODE>(mother (mother carol))</CODE>. We have thus found four grandparents
for Carol.<BR>
<BR>
There is no guarantee, however, that a different proof will yield a
different answer. If we reinvoke <FONT COLOR=navy>SNARK</FONT>  once more, we find yet
another proof, but the answer, <CODE>(father (father carol))</CODE>, is the
same as the first one we discovered. Reinvoking <FONT COLOR=navy>SNARK</FONT>  again yields
more duplicate answers.<BR>
<BR>
<!--TOC subsection Avoiding Duplicate Answers-->

<H3><A NAME="htoc26">4.2</A>&nbsp;&nbsp;Avoiding Duplicate Answers</H3><!--SEC END -->

<A NAME="subsec-avoiding-duplicate-answers"></A>
<A NAME="subsec-subsumption"></A>
If we want to avoid this sort of duplication, we may rely on
<FONT COLOR=navy>SNARK</FONT>'s subsumption mechanism. Subsumption is a strategic control
mechanism which avoids duplication of effort. If the subsumption
strategy is in operation (and it is the default) and two formulas are
derived such that one is logically more general than the other, the
less general formula is discarded. In the clausal case, this happens
when the subsumed clause contains an instance of the subsuming clause
among its disjuncts.<BR>
<BR>
For example, if we have derived the two clauses
<PRE>
  (parent ?x carol)
</PRE>and
<PRE>
  (or (parent (father ?y) carol)
      (grandparent ?w ?z))
</PRE>the latter (``subsumed'') clause will be discarded; only the former
clause will be retained. This is because one of the disjuncts of the
latter clause, <CODE>(parent (father ?y) carol)</CODE> is an instance of the
former; any proof that uses the latter clause will correspond directly
to a proof that uses the former, so there is no need to retain both.<BR>
<BR>
If one clause subsumes another and both have answer formulas, we cannot
discard the subsumed clause without risking loss of answers; a proof
using the subsumed clause may yield a different answer from a proof
using the subsuming clause.
For example, if we pay no attention to answers, a row
<PRE>
(Row 12
   (or (not (parent ?x ?y)) (not (parent ?y carol)))
   . . .
   Answer (ans ?x))
</PRE>is subsumed (as <FONT COLOR=navy>SNARK</FONT>  observes) by the row
<PRE>
(Row 23
   (not (parent ?x carol))
   (resolve 12 father-is-parent)
   Answer (ans (father ?x)))
; Subsumed 12
</PRE>However, if we discard Row 12, we may be losing proofs which yield
answers other than <CODE>(father ?x)</CODE>; Row 23 may be more general but
its answer is not.<BR>
<BR>
If we want to get multiple answers for our query, we must be sure that
the option <TT>use-answers-during-subsumption</TT> is selected; in fact,
this is the default. In this case, the subsumed clause will be
discarded only if its answer is also a special case of the answer
associated with the subsuming clause. In the preceding example, if
answers are used during subsumption, Row 23 will not be regarded as
subsuming Row 12.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  does not normally do subsumption on the final formula <TT>false</TT>; this formula would subsume all the formulas derived previously
or subsequently. However, if we are interested in extracting multiple
answers from proofs without duplicating answers, we must select the
option <TT>use</TT>-<TT>subsumption</TT>-<TT>by</TT>-<TT>false</TT>; this option
is not selected by default. Then the final <TT>false</TT> formula of the
first proof will subsume all derived rows whose answer formula is
an instance of (or identical to) the answer already found; formulas
with different answers will be retained.<BR>
<BR>
If we select the option <TT>use-subsumption-by-false</TT> for
the problem of finding Carol's grandparents, the final row of the
first proof,
<PRE>
(Row 30
   false
   ...
   Answer (ans (father (father carol))))
</PRE>will subsume any row with the answer <CODE>(father (father carol))</CODE>.
All these rows will be discarded. However, rows that contain
distinct answers, such as <CODE>?x</CODE>, <CODE>(father ?x)</CODE>, and
<CODE>(father (mother ?x))</CODE>, will be retained.
If we invoke <FONT COLOR=navy>SNARK</FONT>  four
times, we get the four different grandparents of Carol, as before.
If we have not introduced any assertions other than the ones presented in
Section <A HREF="#subsec-basic-answer-extraction">2.5</A>, we exhaust the agenda
with the fifth invocation of <FONT COLOR=navy>SNARK</FONT>. All the duplicate answers have
been subsumed.<BR>
<BR>
On the other hand, if we have introduced the assertion
<PRE>
  (assert
   '(implies
     (grandparent ?x ?z)
     (and (parent ?x (link ?x ?z))
          (parent (link ?x ?z) ?z)))
          :name 'grandparent-is-parent-of-parent)
</PRE>as in Section <A HREF="#subsec-skolemization">3.3</A>,
we will obtain an endless stream of additional answers, such as
<PRE>
  (father (link (father (father carol)) carol))
</PRE>This is another way of describing Carol's paternal grandfather,
<PRE>
  (father (father carol))
</PRE>It is not a new answer, just a different representation for one of the
answers we have seen previously. We shall call this sort of
repetition of answers <EM>semantic</EM> duplication, to distinguish it
from <EM>syntactic</EM> duplication, in which literally the same answer
appears more than once.<BR>
<BR>
Of course, we could simply remove the assertion <TT>grandparent</TT>-<TT>is</TT>-<TT>parent</TT>-<TT>of</TT>-<TT>parent</TT>, but it
may be necessary for some other proofs. In Section
<A HREF="#subsec-constructive-answer-restriction">4.3</A>, which follows, we shall
see a mechanism for avoiding this sort of duplication.<BR>
<BR>
<!--TOC subsection Constructive Answer Restriction-->

<H3><A NAME="htoc27">4.3</A>&nbsp;&nbsp;Constructive Answer Restriction</H3><!--SEC END -->

<A NAME="subsec-constructive-answer-restriction"></A>
There is no way of eliminating semantic duplication of answers
altogether, but <FONT COLOR=navy>SNARK</FONT>'s ``constructive-answer restriction''
mechanism is one way of reducing semantic duplication. More
important, it ensures that answers are provided in terms of a useful
vocabulary. Let us see how this mechanism operates.<BR>
<BR>
Suppose, in the theory we have been developing, we have provided the
assertion that Carol's mother is Betty, i.  e.,
<PRE>
  (assert '(= (mother carol) betty))
</PRE>If we want to ask who is
Carol's mother, our query is then
<PRE>
  (prove '(= ?person (mother carol)) :answer '(ans ?person))
</PRE>As it stands now, we will get two answers, <TT>betty</TT> and
<CODE>(mother carol)</CODE>. The second answer is correct but unhelpful---if
we ask ``Who is the mother of Carol?'', we are not happy to be told
``the mother of Carol,'' even though the mother of Carol is certainly
the mother of Carol. One way to avoid such unhelpful answers is to
indicate that the answer must be expressed without mentioning the
function symbol <TT>mother</TT>. To do this, we select the option <TT>use-constructive-answer-restriction</TT> (as in Section
<A HREF="#subsec-select-option">2.3</A>) and, after
initialization but before beginning the proof, we make the declaration
<PRE>
  (declare-function-symbol 'mother 1 :allowed-in-answer nil)
</PRE>
This means that we will reject all rows that contain the function
symbol <TT>mother</TT> in the answer formula. If we like, we can combine
this declaration with the sort declaration:
<PRE>
  (declare-function-symbol 'mother 1 :sort '(woman person)
      :allowed-in-answer nil)
</PRE>
If we ask who is the mother of Carol with the above declarations, we
get only the single answer <TT>betty</TT>. The proof-steps that lead to
the answer <CODE>(mother carol)</CODE> are rejected because their answer
contain the forbidden symbol <TT>mother</TT>.<BR>
<BR>
The example in Section <A HREF="#subsec-avoiding-duplicate-answers">4.2</A> affords
another example of the use of the constructive answer restriction to
avoid semantically duplicated answers. In finding the grandparents of
Carol, we obtain an endless stream of answers, such as
<PRE>
  (father (link (father (father carol)) carol))
</PRE>in terms of the function <TT>link</TT>. If we use the constructive
answer restriction and prohibit the function symbol <TT>link</TT> to
appear in an answer, we obtain only the four distinct grandparents of
Carol.<BR>
<BR>
Constants and predicate symbols may also be declared to be disallowed
in the answer, although the reason for disallowing a predicate symbol
in the answer will not become apparent until we discuss conditional
answers (Section <A HREF="#subsec-conditional-answers">4.5</A>). If a symbol has
no declaration, the default is that it is permitted in the answer.<BR>
<BR>
Whether a symbol is allowed in the answer or not is a
context-dependent decision. If we were to ask who a person's
grandparents are, we might be perfectly happy to learn that their
mother's mother is one of them; in that case, we would not declare
that the symbol <TT>mother</TT> is not allowed in the answer.<BR>
<BR>
<!--TOC paragraph Exercise: Riddle.-->

<H5>Exercise: Riddle.</H5><!--SEC END -->

<A NAME="exer-riddle"></A>
There is an old riddle

Brothers and sisters have I none,<BR>
But this man's father is my father's son.<BR>
<BR>
Who am I?

Using the vocabulary we have already introduced, formulate this as a
<FONT COLOR=navy>SNARK</FONT>  problem, add any missing knowledge about family relations as
assertions, and use <FONT COLOR=navy>SNARK</FONT>  to solve the riddle.<BR>
<BR>
<!--TOC subparagraph Hint.-->

<H5>Hint.</H5><!--SEC END -->

Define two people to be siblings if they are distinct and have at
least one parent in common.<BR>
<BR>
Phrase ``Brothers and sisters have I none'' as an
assertion ``I have no siblings.'' (Declare <TT>i</TT> to be a constant
that is not allowed in the answer.)<BR>
<BR>
Phrase ``This man's father is my father's son'' as an assertion ``My
father is a parent of this man's.'' (Declare <TT>this-man</TT> to be a
constant symbol of sort <TT>man</TT>.)<BR>
<BR>
Express as an assertion the fact that ``The male parent is the
father.''<BR>
<BR>
Phrase ``Who am I?'' as the conclusion to be proved, ``I am equal to
?person1'', where ?person1 is the answer.<BR>
<BR>
<!--TOC subparagraph Solution.-->

<H5>Solution.</H5><!--SEC END -->

Here are the declarations of <TT>i</TT> and <TT>this-man</TT>:
<PRE>
  (declare-constant-symbol 'i
                           :allowed-in-answer nil
                           :sort 'person)
  (declare-constant-symbol 'this-man :sort 'man)
</PRE>The first verse ``Brothers and sisters have I
none'' is expressed by the assertion
<PRE>
  (assert '(not (sibling i ?person))
          :name 'brothers-and-sisters-have-i-none)
</PRE>The second verse, ``This man's father is my father's son'' is
expressed by the assertion
<PRE>
  (assert '(parent (father i) (father this-man))
          :name 'this-mans-father-is-my-fathers-son)
</PRE>The fact that a male parent is the father is expressed by the
assertion
<PRE>
  (assert
   '(iff
     (parent ?man ?person)
     (= ?man (father ?person)))
   :name 'male-parent-is-father)
</PRE>The definition of sibling is given by
<PRE>
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (and
      (not (= ?person1 ?person2))
      (exists (?person)
           (and
            (parent ?person ?person1)
            (parent ?person ?person2)))))
   :name 'siblings-share-a-parent)
</PRE>Note that is is necessary to state explicitly that siblings are
distinct; even though I have the same parents as myself, I am not my
own sibling. Note also that the solution doesn't work if we insist
that siblings means full siblings---we must include half siblings.<BR>
<BR>
The question is phrased as the conjecture
<PRE>
  (prove '(= i ?person1)
         :name 'who-am-i
         :answer '(ans ?person1))
</PRE>Note that if we hadn't declared <TT>i</TT> to be disallowed in the
answer, we could have obtained <TT>i</TT> as the answer---correct but not
helpful.<BR>
<BR>
<!--TOC subparagraph Remark: Skolem functions in answers.-->

<H5>Remark: Skolem functions in answers.</H5><!--SEC END -->
 In the preceding
 riddle exercise (Section <A HREF="#exer-riddle">4.3</A>), suppose we had
 included the assertion <TT>grandparent</TT>-<TT>iff</TT>-<TT>parent</TT>-<TT>of</TT>-<TT>parent</TT>, with the explicit existential
 quantifier. If we invoked <FONT COLOR=navy>SNARK</FONT>  again, we could have obtained
 the additional answer
<PRE>
  (#:person-sk1 (father (father this-man)) this-man)
</PRE>In other words, I am the person who is the parent of this man and
the child of his grandfather. Another answer we can obtain by a
further invocation of <FONT COLOR=navy>SNARK</FONT>  is
<PRE>
  (#:person-sk1 (mother (father this-man)) this-man)
</PRE>Here <CODE>#:person-sk1</CODE> is the skolem function that resulted when
<FONT COLOR=navy>SNARK</FONT>  removed the existential quantifier from the assertion.
These answers are semantic duplicates---they are both equal to
<CODE>(father this-man)</CODE>.<BR>
<BR>
If we prefer that a particular skolem function not be
allowed in the answer, we may mark the variable of the
quantifier in the same way that we would mark a constant,
function, or predicate symbol. For instance, if we replaced the
existential quantifier <CODE>exists (?person)</CODE> of the assertion <TT>grandparent-iff</TT>-<TT>parent</TT>-<TT>of-parent</TT> with
<PRE>
  exists ((?person :allowed-in-answer nil))
</PRE>we would obtain only the first answer <CODE>(father this-man)</CODE>, not
the other two, in answering the riddle. (Note again that the double
parentheses are required.) On there other hand, there will be times
when we do want to have skolem functions in answers; see, for example
the problem of the red-headed grandmother, in the forthcoming Section
<A HREF="#subsec-conditional-answers">4.5</A>.<BR>
<BR>
<!--TOC paragraph Exercise: Cousins.-->

<H5>Exercise: Cousins.</H5><!--SEC END -->

<A NAME="exer-cousins"></A>
Introduce assertions that define notions of <TT>siblings</TT> and
<TT>cousins</TT>. These should express the facts that siblings
have at least one parent in common, as in the riddle
exercise, Section <A HREF="#exer-riddle">4.3</A>) and that cousins are children of
siblings. (We consider only first cousins here.)
Use <FONT COLOR=navy>SNARK</FONT>  to prove that cousins have a grandfather in common.
<!--TOC subparagraph Solution.-->

<H5>Solution.</H5><!--SEC END -->
 The definition of <TT>sibling</TT> is given by the
assertion
<PRE>
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (and
      (not (= ?person1 ?person2))
      (exists (?person)
           (and
            (parent ?person ?person1)
            (parent ?person ?person2)))))
   :name 'siblings-share-a-parent)
</PRE>The definition of <TT>cousin</TT> is given by the assertion
<PRE>
  (assert
   '(iff
     (cousin ?person1 ?person2)
     (exists (?person3 ?person4)
             (and
              (parent ?person3 ?person1)
              (parent ?person4 ?person2)
              (sibling ?person3 ?person4))))
   :name 'cousins-are-children-of-siblings)
</PRE>The conclusion to prove is
<PRE>
  (prove
   '(forall (?person1 ?person2)
         (implies
          (cousin ?person1 ?person2)
          (exists (?person)
                  (and
                   (grandparent ?person ?person1)
                   (grandparent ?person ?person2)))))
   :name 'cousins-share-a-grandparent)
</PRE>
Note that we cannot omit the existential quantifier
<PRE>
  (exists (?person)...)
</PRE>because it is
within the scope of the universal quantifier
<PRE>
  (forall (?person1 ?person2)...)
</PRE>Omitting the explicit existential quantifier would create an invisible
existential quantifier that would surround the entire query---the
order of the quantifiers would be reversed and the meaning of the
query would be changed. We would be trying to prove the existence of
a single person who is a common grandparent of all pairs of cousins,
but no such person exists.<BR>
<BR>
<!--TOC subsection Existentially Quantified Variables in Answers-->

<H3><A NAME="htoc34">4.4</A>&nbsp;&nbsp;Existentially Quantified Variables in Answers</H3><!--SEC END -->

<A NAME="subsec-existentials-in-answers"></A>
Normally the answer field contains question-mark variables that are
unquantified in the query. Although these variables have tacit
existential quantification, they are not inside the scope of any
explicit quantifier.<BR>
<BR>
Sometimes, however, we would like to have the variable of an explicit
existential quantifier in a query appear in an answer. A special
mechanism is required to do this, because the answer formula is not
within the scope of the existential quantifier.<BR>
<BR>
For instance, in the Cousins exercise (Section <A HREF="#exer-cousins">4.3</A>),
suppose we would like to find the cousins' common grandparent, as well
as to prove that this person exists. We might be tempted to phrase
the query like this:
<PRE>
  (prove
   '(forall (?person1 ?person2)
         (implies
          (cousin ?person1 ?person2)
          (exists (?person)
                  (and
                   (grandparent ?person ?person1)
                   (grandparent ?person ?person2)))))
   :name 'cousins-share-a-grandparent
   :answer '(ans ?person))
</PRE>However, because the variable <TT>person</TT> in the answer is outside
the scope of the existential quantifier, it does not refer to the same
person.<BR>
<BR>
To remedy this, we may mark the variable as <TT>global</TT>, by writing
it as <CODE>(?person :global t)</CODE>. The query is then phrased as
<PRE>
  (prove
   '(forall (?person1 ?person2)
         (implies
          (cousin ?person1 ?person2)
          (exists ((?person :global t))
                  (and
                   (grandparent ?person ?person1)
                   (grandparent ?person ?person2)))))
   :name 'cousins-share-a-grandparent
   :answer '(ans ?person))
</PRE>This tells <FONT COLOR=navy>SNARK</FONT>  that the variable <TT>?person</TT> refers to the same
thing throughout the row, whether it is inside or outside the scope of
the existential quantifier.<BR>
<BR>
From this query, we obtain the answer
<PRE>
  (ans
   (#:common-parent1
    (#:a-parent2 #:person-sk8 #:person-sk9)
    (#:b-parent3 #:person-sk8 #:person-sk9)))
</PRE>Here we have used the <TT>:conc-name</TT> feature to give names to the
skolem functions in the assertions. Thus <CODE>#:common-parent1</CODE> is the
common parent of two siblings; we have rephrased the assertion as
<PRE>
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (and
      (not (= ?person1 ?person2))
      (exists ((?person :conc-name common-parent))
           (and
            (parent ?person ?person1)
            (parent ?person ?person2)))))
   :name 'siblings-share-a-parent)
</PRE>Similarly, <CODE>#:a-parent2</CODE> and <CODE>#:b-parent3</CODE> are the siblings
who are parents of two cousins, in the assertion <TT>cousins</TT>-<TT>share</TT>-<TT>a</TT>-<TT>grandparent</TT>. The skolem constants
<CODE>#:person-sk8</CODE> and <CODE>#:person-sk9</CODE> are the two given cousins.
<!--TOC subsection Conditional Answers-->

<H3><A NAME="htoc35">4.5</A>&nbsp;&nbsp;Conditional Answers</H3><!--SEC END -->

<A NAME="subsec-conditional-answers"></A>
Sometimes it is not possible to find a single definite answer to a
query, but it can be shown that one of several entities will satisfy
the query, depending on contingencies. In this case, <FONT COLOR=navy>SNARK</FONT>  can
produce a conditional answer. This is particularly useful if we are
using <FONT COLOR=navy>SNARK</FONT>  to construct a program, because it allows for the
introduction of conditional expressions, or tests, into the program
being constructed.<BR>
<BR>
For example<SUP><A NAME="text4" HREF="#note4">4</A></SUP>, in the theory of family relations, suppose we
are told that Alice is a grandparent of Carol, that Alice is
red-headed, but that Carol is not red-headed. We would like to find a
pair <TT>?person1</TT> and <TT>?person2</TT> such that <TT>?person1</TT> is a
parent of <TT>?person2</TT>, where <TT>?person1</TT> is red-headed but <TT>?person2</TT> is not.<BR>
<BR>
Recall that (in Section <A HREF="#subsec-skolemization">3.3</A>) we introduced
an assertion that a grandparent is always the parent of a parent, or,
more precisely,
<PRE>
  (assert
   '(implies
     (grandparent ?person1 ?person2)
     (and (parent ?person1 (link ?person1 ?person2))
          (parent (link ?person1 ?person2) ?person2)))
   :name 'grandparent-is-parent-of-parent)
</PRE>This version of the assertion uses the explicit function <TT>link</TT>;
later we shall consider what happens if we use the version with the
existential quantifier.<BR>
<BR>
The assertion tells us that if Alice is a grandparent of Carol, there
is a link between them, a child of Alice who is a parent of Carol.
The answer to our query then depends on whether this link is
red-headed or not. If so, the link and Carol satisfy the query,
because the link is red-headed but Carol is not. Otherwise, Alice and
the link satisfy the query, because Alice is red-headed and the link
is not. Thus, a conditional answer is called for.<BR>
<BR>
To construct conditional answers, we must select the <FONT COLOR=navy>SNARK</FONT>  option
<TT>use</TT>-<TT>conditional</TT>-<TT>answer</TT>-<TT>creation</TT> (See Section
<A HREF="#subsec-select-option">2.3</A>); it is not the
default. We introduce the assertions that specify the situation:
<PRE>
  (assert '(grandparent alice carol)
          :name 'alice-is-grandparent-of-carol)

  (assert '(red-headed alice)
          :name 'alice-is-red-headed)

  (assert '(not (red-headed carol))
          :name 'carol-is-not-red-headed)
</PRE>Then we pose the query:
<PRE>
  (prove '(and
           (parent ?person1 ?person2)
           (red-headed ?person1)
           (not (red-headed ?person2)))
         :name 'red-headed-parent
         :answer '(parent ?person1 ?person2))
</PRE><FONT COLOR=navy>SNARK</FONT>  proves the conclusion and yields that answer
<PRE>
  (answer-if
   (red-headed (link alice carol))
   (parent (link alice carol) carol)
   (parent alice (link alice carol)))
</PRE>In other words, if the link between Alice and Carol is red-headed,
then the link and Carol are the desired pair; otherwise, Alice and the
link are the pair. This agrees with our informal reasoning.<BR>
<BR>
If we fail to invoke <TT>use</TT>-<TT>conditional</TT>-<TT>answer</TT>-<TT>creation</TT>, <FONT COLOR=navy>SNARK</FONT>  will not form
a conditional answer. Instead it will form a disjunction of the
instances of the answer formula that satisfy the query, without
indicating which instance holds in which situation. In this case, it
will produce the answer
<PRE>
 (or
  (parent (link alice carol) carol)
  (parent alice (link alice carol))))
</PRE>
<!--TOC section Efficiency Considerations-->

<H2><A NAME="htoc36">5</A>&nbsp;&nbsp;Efficiency Considerations</H2><!--SEC END -->

<A NAME="sec-efficiency-considerations"></A>
In this section we discuss several mechanisms for improving <FONT COLOR=navy>SNARK</FONT>'s
performance, including associative and commutative unification
(Section <A HREF="#subsec-commutative-and-associative">5.1</A>), the set-of-support
strategy (Section <A HREF="#subsec-set-of-support">5.2</A>), the recursive-path and
predicate ordering strategies (Sections <A HREF="#subsec-recursive-path">5.3</A>
and <A HREF="#subsec-predicate-ordering">5.4</A>), and rewrite rules (Section
<A HREF="#subsec-rewrite-rules">5.6</A>).<BR>
<BR>
When appropriate options are selected, <FONT COLOR=navy>SNARK</FONT>  is a logically complete
theorem prover; in other words, if a conclusion follows from the
assertions, <FONT COLOR=navy>SNARK</FONT>, equipped with the appropriate inference rules,
will eventually find a proof. However, as the length of the proof or
the number of assertions grows, the truth of the preceding sentence
relies more and more on the word ``eventually''.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>'s strategic mechanisms allow us to tune its performance for a
particular subject domain or theory. If used properly, they can have
a dramatic effect on the size of the search space and on the time
necessary to discover a proof. Whereas none of them is necessary for
the examples in this guide, their use is essential if we are
dealing with a large theory or searching for a long or difficult
proof. However, some care is required in the use of control
strategies. Subtle misuse of rewrite rules, for example, can lead to
incompleteness or even infinite looping. While the set-of-support and
the recursive-path ordering strategies retain completeness when used
separately, the two can cause loss of completeness when used together.
Any of them may be incompatible with hyperresoluton or the
constructive answer restriction. While it may be justifiable to
sacrifice completeness for the sake of improved performance, the user
should be aware that if <FONT COLOR=navy>SNARK</FONT>  fails to find a proof, the cause may
be unforeseen interactions with control strategies. In such a case,
we can experiment with disengaging the strategies.<BR>
<BR>
<!--TOC subsection Commutative and Associative Symbols-->

<H3><A NAME="htoc37">5.1</A>&nbsp;&nbsp;Commutative and Associative Symbols</H3><!--SEC END -->

<A NAME="subsec-commutative-and-associative"></A>
 <FONT COLOR=navy>SNARK</FONT>  has special-purpose unification algorithms that allow us to
reason about symbols with special properties, without introducing
assertions that express these properties.<BR>
<BR>
For example, the <TT>sibling</TT> relation we introduced in the riddle
exercise (Section <A HREF="#exer-riddle">4.3</A>) is commutative: if Arthur and
Susan are siblings, then so are Susan and Arthur. The order is
irrelevant.<BR>
<BR>
We could express this property by an assertion
<PRE>
  (assert
   '(iff
     (sibling ?person1 ?person2)
     (sibling ?person2 ?person1))
   :name 'symmetry-of-sibling)
</PRE>(It would suffice to use <TT>implies</TT> rather than <TT>iff</TT> here.) However,
that assertion would have many consequences; the resolution rule applies to
it and any formula that mentions the <TT>sibling</TT> relation. Most of these
consequences would be irrelevant to the problem at hand, and each of them
would have its own consequences in turn, and so on. We could be swamped by
the proliferation of irrelevant clauses.<BR>
<BR>
Instead we choose to declare that <TT>sibling</TT> is a
commutative predicate, and drop the assertion. For this purpose, we
include the declaration
<PRE>
  (declare-predicate-symbol 'sibling 2 :commutative t)
</PRE>anywhere after initialization and before use of the symbol. This means that
the commutative unification algorithm will be used when we attempt to unify
two atoms with the predicate symbol <TT>sibling</TT>. Although commutative
unification is slower than ordinary unification, its employment here prevents
<FONT COLOR=navy>SNARK</FONT>  from generating lots of unnecessary consequences.<BR>
<BR>
We can declare function symbols as well as predicate symbols to be
commutative. Function symbols can also be declared to be associative.
For associativity, we use the keyword <TT>:associative</TT>.<BR>
<BR>
If <FONT COLOR=navy>SNARK</FONT>  sees an assertion that is an instance of associativity or
commutativity, it will remove the assertion automatically and instead
declare the appropriate symbol to be associative or commutative.
Thus, if we did chose to include the assertion <TT>symmetry-of-sibling</TT>
as an assertion, <FONT COLOR=navy>SNARK</FONT>  would simply remove the assertion and declare
the relation <TT>sibling</TT> to be commutative.<BR>
<BR>
<!--TOC subsection Set of Support-->

<H3><A NAME="htoc38">5.2</A>&nbsp;&nbsp;Set of Support</H3><!--SEC END -->

<A NAME="subsec-set-of-support"></A>
The set-of-support strategy causes <FONT COLOR=navy>SNARK</FONT>  to pay special attention to a
particular subset of the rows derived in searching for a proof. Typically
this <EM>set of support</EM> includes the desired (negated) conclusion, and often
it includes special hypotheses required for that conclusion to hold, but it
may exclude all the other assertions. In observing the strategy, we only
apply a rule of inference to a set of rows if at least one of the rows is
<EM>supported</EM>, i.  e.,
belongs to the set of support. The newly inferred row is then added to the
set of support.<BR>
<BR>
If we have a large set of assertions and the set of support is
relatively small, applying the strategy may allow us to ignore most of
the assertions and help us focus our attention on inferences that are
related to the desired conclusion.<BR>
<BR>
Selecting the set of support strategy is a bit different from the
selection of other <FONT COLOR=navy>SNARK</FONT>  options. The strategy is always turned
on---there is no way to turn it off---but initially every row is
included in the set of support, which means that the strategy has no
effect; no inferences are excluded.<BR>
<BR>
To actually benefit from the strategy, we must indicate some rows to
be excluded. Normally, we choose the
option
<PRE>
  (assert-supported nil)
</PRE>to exclude all the assertions from the set of support. The option
must be selected before any assertions are made. Inferences can
still be made from these assertions, but only if some member of the set
of support takes part in the inference step. For instance, we can
apply the resolution rule to any assertion and a member of the set of
support, but not to two assertions.<BR>
<BR>
The negation of the conclusion (obtained from the argument of the <TT>prove</TT>
function) will normally be included in the set of support. If there are
certain special assertions that we wish to include in the set of support,
even if assertions are generally excluded,
we can assert them by saying (for a formula <CODE>&lt;Form&gt;</CODE>)
<PRE>
  (assert &lt;Form&gt; :supported t)
</PRE>This will override the general policy that assertions are not to be
supported.<BR>
<BR>
For instance, if we execute
<PRE>
  (assert
    (implies
     (and
      (parent ?person1 ?person2)
      (parent ?person2 ?person3))
     (grandparent ?person1 ?person3))
    :name 'parent-of-parent-is-grandparent
    :supported t)
</PRE>then this assertion will be supported. We might do this because we believe
this assertion will be relevant to the proof, or class of proofs, we are
seeking.<BR>
<BR>
If there are two unsupported
assertions,
<PRE>
  (parent alice betty)
</PRE>and
<PRE>
  (parent betty carol)
</PRE>we can still use resolution and the assertion <TT>parent</TT>-<TT>of</TT>-<TT>parent</TT>-<TT>is</TT>-<TT>grandparent</TT> to deduce
<PRE>
  (grandparent alice carol)
</PRE>If none of these assertions were supported, the inference would be illegal.<BR>
<BR>
Normally a formula that is deduced from a supported formula is also
supported; in other words, being supported is <EM>inherited</EM>.
For example, the formula
 <CODE>(grandparent alice carol)</CODE>
we just deduced will be supported, even though the two facts it was deduced
from,
<CODE>(parent alice betty)</CODE> and <CODE>(parent betty carol),</CODE> are not.
We can
declare that a formula is to be supported but that its supportedness is not
to be inherited by tagging it with the keywords
<PRE>
  :supported :uninherited
</PRE>instead of
<PRE>
  :supported t
</PRE>If the assertion <TT>parent</TT>-<TT>of</TT>-<TT>parent</TT>-<TT>is</TT>-<TT>grandparent</TT> were so tagged, the new deduced formula would not be
supported.<BR>
<BR>
Another way to force a particular assertion <TT>&lt;Form&gt;</TT> to belong to the set
of support is to execute
<PRE>
  (assume &lt;Form&gt;)
</PRE>in place of
<PRE>
  (assert &lt;Form&gt;)
</PRE>The construct <TT>assume</TT> is synonymous with <TT>assert</TT>, but when we
exclude assertions made via <TT>assert</TT> from the set of support by saying
<PRE>
  (assert-supported nil)
</PRE>we have no effect on those assertions made via <TT>assume</TT>; they will still
be supported. Typically, these <EM>assumptions</EM>
are special hypotheses for the theorem being proved, and hence are
particularly likely to be relevant to the proof.<BR>
<BR>
If we choose to, we can even exclude assertions made via <TT>assume</TT> from the
set of support by saying
<PRE>
  (assume-supported nil)
</PRE>This is unusual because the point of having two synonymous constructs,
assertions and assumptions, is that we can support assumptions while
excluding ordinary assertions. We can even exclude the negation of the
conclusion from the set of support by saying
<PRE>
  (prove-supported nil)
</PRE>The reason for doing this sort of thing is to explore the effect of different
search strategies on the same problem.<BR>
<BR>
In some theorem provers and other rule-based systems, a distinction is made
between forward- and backward chaining rules. Forward-chaining rules allow us
to reason forward from assertions; backward-chaining rules allow us to reason
backward from the desired conclusion. The support mechanism in <FONT COLOR=navy>SNARK</FONT>
allows us to mimic the behavior of forward and backward chaining. When we
applied the assertion <TT>parent</TT>-<TT>of</TT>-<TT>parent</TT>-<TT>is</TT>-<TT>grandparent</TT> to two other assertions, we were using it as a forward-chaining
rule. In general, forward-chaining behavior is obtained by supporting
assertions and assumptions; backward-chaining behavior is obtained by
supporting the desired conclusion.<BR>
<BR>
The set-of-support strategy is complete if the complement of the set of
support is satisfiable, that is, if the complement contains no contradictory
formulas. For instance, if all of our assertions are consistent
(satisfiable), the strategy will be complete if only the desired
conclusion is supported.
Caution must be exerted in using the strategy, however, because it
is incompatible with other strategies, as mentioned in the introduction to
this section (Section <A HREF="#sec-efficiency-considerations">5</A>). The default in
<FONT COLOR=navy>SNARK</FONT>  is that all assertions, assumptions, and desired conclusions are
supported---in other words, the set-of-support strategy does not impede any
inference. This is a conservative choice---completeness will not be lost
because of incompatibilities between set-of-support and other strategies---but
for some problems it may not be the most efficacious decision.<BR>
<BR>
The value of the set-of-support strategy is illustrated by the proof for the
riddle exercise of Section <A HREF="#exer-riddle">4.3</A>, which puts 218 rows on the
agenda if the default settings are used, but only 50 rows if assertions are
excluded from the set of support and only the negation of the conclusion is
included; the time required is less than half. Exact figures depend on how
many assertions are in the theory, of course. The more irrelevant assertions
in the theory, the more important the strategy becomes.<BR>
<BR>
<!--TOC subsection Recursive-Path Ordering Strategy-->

<H3><A NAME="htoc39">5.3</A>&nbsp;&nbsp;Recursive-Path Ordering Strategy</H3><!--SEC END -->

<A NAME="subsec-recursive-path"></A>
 <FONT COLOR=navy>SNARK</FONT>  has a number of mechanisms by which we can impose an ordering
on the symbols in our vocabulary, which can give <FONT COLOR=navy>SNARK</FONT>  a sense of
direction in searching for a proof. These orderings say that certain
expressions are preferable to certain others, and will restrict the
action of <FONT COLOR=navy>SNARK</FONT>'s rules so that they will tend to remove the less
favored expressions. We discuss two ordering strategies: the
recursive-path ordering strategy, which restricts application of the
paramodulation rule, and the predicate ordering strategy, which
restricts application of the resolution rule. Both of these are
referred to as symbol-ordering strategies.<BR>
<BR>
The recursive-path ordering strategy uses an ordering on the constant
and function symbols of our vocabulary. It is invoked by
<PRE>
  (use-term-ordering :recursive-path)
</PRE>The format of this command is unusual because <FONT COLOR=navy>SNARK</FONT>  also allows other such
``term-ordering'' strategies, which may be stipulated here instead.<BR>
<BR>
As we have observed, the paramodulation rule can be applied in two
directions; if the equality is <CODE>(= s t)</CODE>, it can be used
left-to-right to replace <TT>s</TT> with <TT>t</TT> or right-to-left to
replace <TT>t</TT> with <TT>s</TT>. If we do not select an ordering
strategy, <FONT COLOR=navy>SNARK</FONT>  will attempt applying the rule in both directions,
with some redundancy. If we employ the recursive-path ordering
strategy, <FONT COLOR=navy>SNARK</FONT>  can often avoid one of these two directions and
hence reduce the branchiness of the search space.<BR>
<BR>
The recursive-path ordering strategy compares <TT>s</TT> and <TT>t</TT>
according to an ordering before allowing a replacement. If <TT>s</TT> is
greater than <TT>t</TT>, it will not allow us to replace <TT>t</TT> with
<TT>s</TT>; we will only be permitted to apply paramodulation in
left-to-right order. If <TT>t</TT> is greater than <TT>s</TT>, we will only
be allowed to apply the rule right-to-left. In either of these cases,
we say that the equality can be <EM>ordered</EM>. Otherwise, if no order
exists between <TT>s</TT> and <TT>t</TT>, the strategy will allow us to
apply the rule in either direction. For example, the recursive-path
ordering will not allow us to order a commutativity axiom, such as
<PRE>
  (= (f ?x ?y) (f ?y ?x))
</PRE>
As we have seen (Section <A HREF="#subsec-commutative-and-associative">5.1</A>),
<FONT COLOR=navy>SNARK</FONT>  deals with associativity and commutativity, in particular, by
invoking a special-purpose unification algorithm, but other equalities
may be unorderable as well.<BR>
<BR>
To define the ordering on terms, we declare an ordering on the
constant and function symbols. For instance, suppose we prefer that
when we have assertions such as
<PRE>
  (assert '(= (mother carol) betty))
</PRE>we always wish to replace the constant <CODE>betty</CODE> with the term
 <CODE>(mother carol)</CODE> so that we can use properties of the
 function <CODE>mother</CODE>. If so, we can declare the orderings
<PRE>
  (declare-ordering-greaterp 'betty 'mother)
  (declare-ordering-greaterp 'betty 'carol)
</PRE>With this declaration, the equality will be applied in the
right-to-left direction.<BR>
<BR>
The precise definition of recursive-path ordering is
complicated---see, for example, [<CITE><A HREF="#recursive-path">Dershowitz</A></CITE>]---but to order a
ground (variable-less) equality it suffices that all the constant and
function symbols on one side precede all the constant and function
symbols on the other.<BR>
<BR>
If (for ordering other equalities) we want to say that
<CODE>carol</CODE> is also to be preferred to <CODE>mother</CODE>, we can do it in
a single declaration,
<PRE>
  (declare-ordering-greaterp 'betty 'carol 'mother)
</PRE>The ordering we
provide on symbols must be loop-free, and every symbol must previously be
declared---otherwise <FONT COLOR=navy>SNARK</FONT>  will give an error message. Also, the name must
be unambiguous. If we have introduced a constant <TT>betty</TT> and a function
symbol <TT>betty</TT>, <FONT COLOR=navy>SNARK</FONT>  will not know which one we mean and will give an
error message. For this purpose, we should use the alias mechanism (Section
<A HREF="#subsec-sorts">3.2</A>) to give the two <TT>betty</TT>'s distinct aliases, e.  g.,
<TT>betty-con</TT> and <TT>betty-fun</TT>. The declaration can then refer
unambiguously to <TT>betty-con</TT>.<BR>
<BR>
<!--TOC subsection Predicate Ordering Strategy-->

<H3><A NAME="htoc40">5.4</A>&nbsp;&nbsp;Predicate Ordering Strategy</H3><!--SEC END -->

<A NAME="subsec-predicate-ordering"></A>
The predicate ordering strategy, which controls the resolution rule, uses an
ordering on the predicate symbols of our vocabulary and extends the ordering
on terms to apply to atomic formulas. It is selected by <TT>use</TT>-<TT>literal</TT>-<TT>ordering</TT>-<TT>with</TT>-<TT>resolution</TT>. (There is also a
version of the restriction that applies to the paramodulation rule.)<BR>
<BR>
Let us give an example: consider the exercise (Section
<A HREF="#exer-cousins">4.3</A>) in which we showed that cousins have a common
grandparent. Let us see how to introduce an ordering on the predicate
symbols.<BR>
<BR>
We use four predicate symbols here, <TT>parent</TT>, <TT>sibling</TT>, <TT>cousin</TT>, and <TT>grandparent</TT>. Note that <TT>grandparent</TT>
and <TT>sibling</TT> are defined in terms of <TT>parent</TT>, and <TT>cousin</TT> is
defined in terms of <TT>sibling</TT> and <TT>parent</TT>. Therefore, it makes
sense during a proof to paraphrase <TT>cousin</TT> in terms of <TT>sibling</TT> and
<TT>parent</TT>. Then <TT>grandparent</TT> and <TT>sibling</TT> can be paraphrased in
terms of <TT>parent</TT>.<BR>
<BR>
For example, we include the declaration
<PRE>
  (declare-predicate-symbol 'parent 2)
</PRE>We can then include the ordering
<PRE>
  (declare-ordering-greaterp 'cousin 'sibling 'parent)
  (declare-ordering-greaterp 'grandparent 'parent)
</PRE>This means that we will favor inferences that replace <TT>cousin</TT>
with <TT>sibling</TT> or <TT>parent</TT>, that replace <TT>sibling</TT> with
<TT>parent</TT>, or that replace <TT>grandparent</TT> with <TT>parent</TT>. (We
do not say whether we prefer <TT>cousin</TT> or <TT>sibling</TT> to <TT>grandparent</TT>, since we have no opinion on that at this time.)<BR>
<BR>
In proving this result without a symbol ordering, <FONT COLOR=navy>SNARK</FONT>  may
generate more than a thousand rows before discovering a proof.
Selecting this ordering will allow <FONT COLOR=navy>SNARK</FONT>  to find the proof after
generating fewer than a hundred rows. The time required was about
about a twentieth of the time without the ordering strategy.<BR>
<BR>
In comparing two formulas which have the same predicate symbol, the
ordering restriction will use the recursive-path ordering to compare
the argument terms of the two predicate symbols. It is possible to
control the order in which the arguments are compared, but we shall
not discuss this technicality here.<BR>
<BR>
If we want to use an ordering strategy but want <FONT COLOR=navy>SNARK</FONT>  to invent
an ordering for us, we can select the option <TT>use-default-ordering</TT>. <FONT COLOR=navy>SNARK</FONT>'s ordering will agree with any
orderings we have chosen, but <FONT COLOR=navy>SNARK</FONT>  will fill in its own ordering
when we have not made any decision. For example, since we have not
decided whether we prefer <TT>sibling</TT> or <TT>grandparent</TT>, <FONT COLOR=navy>SNARK</FONT>
will decide one way or another, according to its own criteria. Even
if we do not indicate any ordering at all, we may get improved
performance if we use the ordering strategy and the default
ordering, because the search space will be narrower: fewer inferences
are legal at each step.<BR>
<BR>
These ordering restrictions must be used with some care. They are
logically complete in isolation, but they are not in general complete
when used in combination with other strategies, or even with the
constructive answer restriction.<BR>
<BR>
<!--TOC subsection Obtaining Left-to-Right Behavior-->

<H3><A NAME="htoc41">5.5</A>&nbsp;&nbsp;Obtaining Left-to-Right Behavior</H3><!--SEC END -->

<FONT COLOR=navy>SNARK</FONT>  inference rules can operate on any atom in a formula.
Logic-programming languages, such as <FONT COLOR=navy>PROLOG</FONT>, on the other hand, commonly
operate on a formula in left-to-right order. This behavior can be mimicked
in <FONT COLOR=navy>SNARK</FONT>  by tagging a formula to be <EM>sequential</EM>. If a formula is
sequential, only its left-most atom is available to be operated on.<BR>
<BR>
We can indicate that a formula is to be processed sequentially by a keyword
argument, as in
<PRE>
  (assert
    (implied-by
     (grandparent ?person1 ?person3)
     (and
      (parent ?person1 ?person2)
      (parent ?person2 ?person3)))
     :sequential t)
</PRE>This means that to apply the resolution rule, say, to this
formula, we must unify the leftmost atom,
<PRE>
  (grandparent ?person1 ?person3)
</PRE>rather than either of the two subsequent atoms. If we do succeed in deriving
a consequence from this formula, the derived formula is also sequential. In
particular, the instance of the second atom
<PRE>
  (parent ?person1 ?person2)
</PRE>must be operated on before the instance of the third atom
<PRE>
  (parent ?person2 ?person3)
</PRE>can be. If we do not want formulas derived from a sequential formula to be
inherited, we can tag it
<PRE>
  :sequential :uninherited
</PRE>instead of <TT>t</TT>.<BR>
<BR>
If the keyword <TT>:sequential</TT> is not specified, whether a formula is to be
treated sequentially is determined by the current value of <TT>assert-sequential</TT>, <TT>assume-sequential</TT>, or <TT>prove-sequential</TT>. For
instance, if we declare
<PRE>
  (assert-sequential t)
</PRE>all assertions will be sequential.
<FONT COLOR=navy>SNARK</FONT>'s default value is <TT>nil</TT> for
all these options.<BR>
<BR>
To approximate the behavior of <FONT COLOR=navy>PROLOG</FONT>---backward chaining and left-to-right
solution of goals, we declare all
assertions to be sequential and unsupported and we specify
<PRE>
  (prove goal :supported t :sequential t)
</PRE>Because sequentiality is inherited, all the formulas we derive will then be
treated in left-to-right order, as in <FONT COLOR=navy>PROLOG</FONT>.<BR>
<BR>
Like the support restriction, the sequentiality restriction must be used
with care to preserve completeness; it is only complete in special cases.
When using sequentiality, the user is viewing the assertions as programs, to
be executed in order. Predicate-ordering strategies provide a safer way of
indicating which atoms of a formula to operate on first.<BR>
<BR>
<!--TOC subsection Rewrite Rules-->

<H3><A NAME="htoc42">5.6</A>&nbsp;&nbsp;Rewrite Rules</H3><!--SEC END -->

<A NAME="subsec-rewrite-rules"></A>
<FONT COLOR=navy>SNARK</FONT>  has a rewrite rule mechanism that allows us to treat certain
designated equalities or equivalences as rewrite rules. This means
that whenever an occurrence of the left side of the rule appears in a
row (henceforth called the <EM>target</EM>), it will be replaced by the
corresponding instance of the right side of the rule, immediately and
automatically.<BR>
<BR>
For example, in Section <A HREF="#subsec-equivalence">3.4</A>, we used an
assertion to define the grandparent relation:
<PRE>
  (assert
   '(iff
     (grandparent ?person1 ?person2)
     (exists (?person)
             (and (parent ?person1 ?person)
                  (parent ?person ?person2))))
   :name 'grandparent-iff-parent-of-parent)
</PRE>
If we chose to represent the same equivalence by a rewrite rule, we would
instead say
<PRE>
  (assert-rewrite
   '(iff
     (grandparent ?person1 ?person2)
     (exists (?person)
             (and (parent ?person1 ?person)
                  (parent ?person ?person2))))
          :name 'grandparent-iff-parent-of-parent)
</PRE>
There are several differences between these two statements in the way
they are treated by <FONT COLOR=navy>SNARK</FONT>. The rewrite rule will immediately
replace any subformula of form <CODE>(grandparent ?person1 ?person2)</CODE>,
in any <FONT COLOR=navy>SNARK</FONT>  row, with a corresponding formula
<PRE>
  (and (parent ?person1 term) (parent term ?person2))
</PRE>where <TT>term</TT> is either a variable ?person or a skolem term,
depending on the force of the quantifier (see Section
<A HREF="#subsec-quantifier-force">3.3</A>).
The assertions and proof will appear as if the <TT>grandparent</TT>
symbol did not exist.<BR>
<BR>
Phrasing the statement as an assertion, on the other hand, will not
interfere with <FONT COLOR=navy>SNARK</FONT>'s usual operation. Formulas involving the
<TT>grandparent</TT> relation will be placed on the agenda to be
processed in due course. Resolution with the assertion that defines
the relation will not cause the symbol to be replaced---instead, new
rows will be created and added to the agenda.<BR>
<BR>
The fact that rewrite rules cause a replacement instead of an addition
to the agenda means that they can drastically reduce the search
space. In the problem of showing that cousins have a grandparent in
common (Section <A HREF="#exer-cousins">4.3</A>), if we replace the assertions that
define grandparents, cousins and siblings with rewrite rules, we obtain
a proof in a quarter of the time, generating a third the number of
rows.<BR>
<BR>
Another difference between a rewriting and an ordinary inference is
that <FONT COLOR=navy>SNARK</FONT>  will only do one-way matching, not full unification, in
performing a rewriting. It will instantiate variables in the left
side of the rule to force them to be identical to terms in the target
formula, but it will not instantiate variables in the target formula
to force them to be identical to terms in the rule.<BR>
<BR>
For example, suppose we have an ordinary
assertion (not a rewrite rule)
<PRE>
  (assert '(= (mother carol) betty))
</PRE>If we also have in our theory the assertion
<PRE>
  (assert '(parent (mother ?person) ?person)
          :name 'mother-is-parent)
</PRE>Then we can apply paramodulation to the two assertions, instantiating
<TT>person</TT> be <TT>carol</TT>, to obtain
<PRE>
  (parent betty carol)
</PRE>The instantiation was discovered by the
unification algorithm, in unifying the left side of the equality, the term
<CODE>(mother carol)</CODE>, with the subterm <CODE>(mother ?person)</CODE> of the target
assertion, <TT>mother</TT>-<TT>is</TT>-<TT>parent</TT>.<BR>
<BR>
Now suppose we rephrase the theory so that the fact that Carol's mother
is Betty is expressed instead by the rewrite rule
<PRE>
  (assert-rewrite '(= (mother carol) betty))
</PRE>Then we cannot apply the rewrite rule to the assertion <TT>mother</TT>-<TT>is</TT>-<TT>parent</TT>, because <FONT COLOR=navy>SNARK</FONT>
will not instantiate the variable <TT>?x</TT>  in the assertion to create
an instance of the left side of the rule.<BR>
<BR>
<!--TOC subsubsection Proceed with Caution-->

<H4><A NAME="htoc43">5.6.1</A>&nbsp;&nbsp;Proceed with Caution</H4><!--SEC END -->

<A NAME="subsubsec-rewrite-caution"></A>
Rewrite rules can replace one formula with another, rather than merely
adding a new row, because they do not instantiate variables in the
target formula; this means that no proof that requires a different
instantiation is being lost due to the replacement. However, caution
must be exercised in using rewrite rules instead of assertions. Poor
choice of a rewrite rule can lead to incompleteness---<FONT COLOR=navy>SNARK</FONT>  may fail
to prove valid conclusions if a fact is represented as a rewrite rule
rather than as an assertion.<BR>
<BR>
For example, in the theory in which the fact that Betty is Carol's
mother is represented by an assertion, <FONT COLOR=navy>SNARK</FONT>  can answer the query
<PRE>
  (prove '(parent betty ?person) :answer '(ans ?person)
   :name 'who-is-bettys-child?)
</PRE>The negation of the conclusion directly contradicts the assertion
<PRE>
  (parent betty carol)
</PRE>which was obtained by the paramodulation step, giving the answer <TT>carol</TT>.<BR>
<BR>
But if the fact that Betty is Carol's mother is represented by a
rewrite rule, we cannot deduce that Betty is a parent of Carol, and we
cannot answer the query.<BR>
<BR>
Another caution on the use of rewrite rules is that it is the user's
responsibility to see that they terminate. If we chose to represent the
symmetry of the sibling relation by a rewrite rule
<PRE>
  (assert-rewrite
   '(iff (sibling ?person1 ?person2)
         (sibling ?person2 ?person1))
   :name 'symmetry-of-sibling)
</PRE>we would have an infinite computation whenever we used the sibling
relation.<BR>
<BR>
Finally, even if the use of a rewrite rule does not lead to
incompleteness or to an infinite loop, there is no guarantee that it
will speed up the search. For instance, if a rewriting replaces a
simple atomic formula with a complex sentence, it may even make some
proofs more complex.<BR>
<BR>
<!--TOC subsubsection Rewrite Rules May Be Introduced Automatically-->

<H4><A NAME="htoc44">5.6.2</A>&nbsp;&nbsp;Rewrite Rules May Be Introduced Automatically</H4><!--SEC END -->

<A NAME="subsubsec-rewrite-automatic"></A>
<FONT COLOR=navy>SNARK</FONT>  will sometimes introduce rewrite rules automatically, to increase its
efficiency, when it observes a suitable opportunity. If we select the option
<TT>use</TT>-<TT>simplification</TT>-<TT>by</TT>-<TT>equalities</TT>, <FONT COLOR=navy>SNARK</FONT>  will
introduce rewrite rules from asserted or deduced equalities. For example, if
we are using the recursive-path ordering strategy and deduce an equality
that can be ordered by the strategy, <FONT COLOR=navy>SNARK</FONT>  will introduce a rewrite rule
that will have the same effect.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>, in contrast with a human being, will never introduce rewrite rules
that lead to incompleteness or looping. Therefore, rather than introducing a
rewrite by hand, it is usually preferable for a user to introduce an ordinary
assertion and to provide a symbol ordering that will cause <FONT COLOR=navy>SNARK</FONT>  to
introduce the rewrite automatically, if it is safe.<BR>
<BR>
Even if we have not selected special options, if we have a unit assertion
<CODE>P</CODE>, <FONT COLOR=navy>SNARK</FONT>  will introduce a rewrite rule
<PRE>
  (assert-rewrite '(iff P true)).
</PRE>Application of the rewrite rule will produce
some of the effects of the resolution rule; for instance, if we have a clause
<PRE>
  (or (not P') Q)
</PRE>where <TT>P'</TT> is an instance of <TT>P</TT>, applying the rule will (after
simplification) yield the clause <CODE>Q</CODE>; this same clause would ultimately
have been obtained by resolution with the unit clause <CODE>P</CODE>, if the
rewrite rule had not been in place. But the rewrite rule will be applied
immediately and automatically, when it becomes applicable as the result of
applying other rules.<BR>
<BR>
This explains why we have seen <FONT COLOR=navy>SNARK</FONT>  traces in which rewriting has been
applied, even when we have not introduced any rewrite rules. For example,
the last step of the proof in the Grandchildren-of-Alice example, Section
<A HREF="#example-grandchildren-of-alice">3.5</A>, is a resolution followed by a rewrite
that has the effect of a second resolution with a unit assertion---<FONT COLOR=navy>SNARK</FONT>
has effectively combined two resolution steps into one.<BR>
<BR>
In cases in which <FONT COLOR=navy>SNARK</FONT>  invents a rewrite rule corresponding to an assertion, it will also
leave the assertion in place, so that other rules, such as paramodulation and
resolution, can be applied.<BR>
<BR>
<!--TOC paragraph Exercise: Efficiency-->

<H5>Exercise: Efficiency</H5><!--SEC END -->

<A NAME="exec-efficiency"></A>
Experiment with the previous exercises to see if you can improve the
time required or the number of rows produced by using the
set-of-support strategy, symbol orderings, or rewrite rules.<BR>
<BR>
<!--TOC section Temporal Reasoning-->

<H2><A NAME="htoc46">6</A>&nbsp;&nbsp;Temporal Reasoning</H2><!--SEC END -->

<A NAME="sec-temporal-reasoning"></A>
Reasoning about time plays a central role in many knowledge-representation
applications. <FONT COLOR=navy>SNARK</FONT>'s temporal representation supports two kinds of
temporal entities, time points and time intervals, and relationships
between them, and is an extension of the temporal interval logic of Allen
[<CITE><A HREF="#allen">Allen</A></CITE>]. It also supports times of day and calendar dates. Many of the
relation names in <FONT COLOR=navy>SNARK</FONT>'s temporal representation were adapted from Cyc's
upper ontology [<CITE><A HREF="#cyc-ul">Cyc-UL</A></CITE>].<BR>
<BR>
A possible approach to reason with time is to provide the axioms for the
desired temporal inferences, and rely on <FONT COLOR=navy>SNARK</FONT>'s general-purpose inference
methods, such as resolution and paramodulation, to draw conclusions. This
approach can involve a good deal of time-consuming search. Alternatively,
one may use special-purpose inference methods for reasoning with temporal
knowledge. A special-purpose reasoner can significantly improve
the speed of inference, but a suitable interface to the general-purpose
inference procedure must be designed. <FONT COLOR=navy>SNARK</FONT>  supports a time and date
procedure with an interface to the ordinary resolution rule, based on the
<EM>constraint resolution</EM> framework [<CITE><A HREF="#burckert">Burckert</A></CITE>].<BR>
<BR>
The <FONT COLOR=navy>SNARK</FONT>  temporal reasoning facility is switched on by selecting the
option <CODE>use-temporal-reasoning</CODE>, e.  g., by evaluating
<PRE>
  (default-use-temporal-reasoning)
</PRE>before initialization; henceforth, in this section, we assume that the
facility has been turned on. When using temporal reasoning, special meaning
is given to certain symbols, such as <TT>time-point</TT>; it is possible for
the user to rename these symbols.<BR>
<BR>
We begin with the relations that apply to time points; later we will consider
time intervals and relations between time points and intervals.<BR>
<BR>
<!--TOC subsection Time Points-->

<H3><A NAME="htoc47">6.1</A>&nbsp;&nbsp;Time Points</H3><!--SEC END -->

A time point is a single moment of time; these are of sort
<CODE>time-point</CODE>. Terms of this sort can be treated like any other terms;
they may be arguments of predicate and function symbols, for example. There
are some built-in operations that are already declared on time points.<BR>
<BR>
There are three primitive relations between pairs of time points:
<UL><LI>
 <CODE>(before ?time-point1 ?time-point2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial001.gif"><BR>
<CODE>?time-point1</CODE> is (strictly) earlier than
 <CODE>?time-point2</CODE>.<BR>
<BR>
(In general, we use the word <EM>strict</EM> to apply to relations that do not
allow time points to occur simultaneously.) Here moving from left to right
corresponds to the passing of time.<BR>
<BR>
<LI><CODE>(after ?time-point1 ?time-point2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial002.gif"><BR>
<CODE>?time-point1</CODE> is
 later than <CODE>?time-point2</CODE>.<BR>
<BR>
<LI><CODE>(simultaneous-with ?time-point1 ?time-point2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial003.gif"><BR>
<CODE>?time-point1</CODE> is
 simultaneous with <CODE>?time-point2</CODE>.
</UL>
Note that these three relations are mutually exclusive and exhaustive: for
any two time points, precisely one of these is true. Also note that the
relation <CODE>simultaneous-with</CODE> is not the same as ordinary equality: one
could have two time points that occur simultaneously but are different in
other respects, e.g., one is the beginning of a new millennium and the other
is the end of the old one. One of these time points could be regarded as
happy, the other as sad, so they are not equal. Temporally, however, they
are treated as identical. If one wants true equality, one should use instead
the relation <CODE>=</CODE>, which is stronger than
<CODE>simultaneous-with</CODE> and has the same effect in temporal reasoning.<BR>
<BR>
Given a set of temporal relations between time points, <FONT COLOR=navy>SNARK</FONT>  will be able
to draw conclusions from them. For example, suppose we are given four
time points such that
<PRE>
 (before time1 time2)
 (simultaneous-with time2 time3)
 (after time4 time3)
</PRE>
This situation can be depicted as follows:
<IMG SRC="tutorial004.gif"><BR>
Then the temporal reasoning component within <FONT COLOR=navy>SNARK</FONT>  will be able to
conclude that
<PRE>
  (before time1 time4)
</PRE>
 <FONT COLOR=navy>SNARK</FONT>  is complete and efficient for this kind of reasoning; in other
words, if a conclusion about time points follows from a set of facts asserted
using only the above three temporal relations, <FONT COLOR=navy>SNARK</FONT>  will be able to deduce
the conclusion.<BR>
<BR>
<!--TOC subsection Time Intervals-->

<H3><A NAME="htoc48">6.2</A>&nbsp;&nbsp;Time Intervals</H3><!--SEC END -->

A time interval is a finite connected region of time. Time intervals are
 of sort <CODE>time-interval</CODE>, which is disjoint from <CODE>time-point</CODE>;
 that is, no entity is both a time point and a time interval.<BR>
<BR>
A time interval has end-points, which are time points, and it also has
interior time points, which occur during the time interval. As in the Allen
logic, we do not identify a time interval with a set of time points. The
Allen logic is even agnostic about whether the end-points are part of the
interval; that is not a meaningful question, because the original logic does
not mention time points.<BR>
<BR>
Each time interval has a start-point and an end-point, which are time points.
Time intervals are always thought of as being nonempty, in the sense that
the start-point is always strictly earlier than the end-point.<BR>
<BR>
<!--TOC subsubsection Allen Primitives-->

<H4><A NAME="htoc49">6.2.1</A>&nbsp;&nbsp;Allen Primitives</H4><!--SEC END -->

<A NAME="subsubsec-allen-primitives"></A>
There are thirteen fundamental relations, known as the <EM>Allen primitives</EM>,
between pairs of time intervals. We say that the relation is <EM>strict</EM> if it does not allow the start- or end-points to be identical.
<UL><LI>
<CODE>(before ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial005.gif"><BR>
The end-point of <CODE>?time-interval1</CODE> is
 (strictly) earlier than the start-point of <CODE>?time-interval2</CODE>.<BR>
<BR>
<LI><CODE>(meets ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial006.gif"><BR>
The end-point of <CODE>?time-interval1</CODE> is
 simultaneous with the start-point of <CODE>?time-interval2</CODE>.<BR>
<BR>
<LI><CODE>(overlaps ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial007.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is
 earlier than the start-point of <CODE>?time-interval2</CODE>, but
the end-point of <CODE>?time-interval1</CODE> is
 (strictly) between the start- and end-points of <CODE>?time-interval2</CODE><BR>
<BR>
<LI><CODE>(starts ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial008.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is
 simultaneous with the start-point of <CODE>?time-interval2</CODE>, but
 the end-point of <CODE>?time-interval1</CODE> is
 earlier than the end-point of <CODE>?time-interval2.</CODE><BR>
<BR>
<LI><CODE>(during ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial009.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is
 later than the start-point of <CODE>?time-interval2</CODE>, but
 the end-point of <CODE>?time-interval1</CODE> is
 earlier than the end-point of <CODE>?time-interval2.</CODE><BR>
<BR>
<LI><CODE>(finishes ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial010.gif"><BR>
The end-point of <CODE>?time-interval1</CODE> is
 simultaneous with the end-point of <CODE>?time-interval2</CODE>, but
 the start-point of <CODE>?time-interval1</CODE> is
 later than the start-point of <CODE>?time-interval2.</CODE></UL>
The next six Allen primitives are the inverses of the first six.
<UL><LI>
<CODE>(after ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial011.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is later
 than the end-point of <CODE>?time-interval2</CODE>.<BR>
<BR>
<LI><CODE>(met-by ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial012.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is
 simultaneous with the end-point of <CODE>?time-interval2</CODE>.<BR>
<BR>
<LI><CODE>(overlapped-by ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial013.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is
 between the start- and end-points of <CODE>?time-interval2</CODE>, but
the end-point of <CODE>?time-interval1</CODE> is
 later than the end-point of <CODE>?time-interval2</CODE>.<BR>
<BR>
<LI><CODE>(started-by ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial014.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is
 simultaneous with the start-point of <CODE>?time-interval2</CODE>, but
 the end-point of <CODE>?time-interval1</CODE> is
 later than the end-point of <CODE>?time-interval2.</CODE><BR>
<BR>
<LI><CODE>(contains ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial015.gif"><BR>
The start-point of <CODE>?time-interval1</CODE> is
 earlier than the start-point of <CODE>?time-interval2</CODE>, but
 the end-point of <CODE>?time-interval1</CODE> is
 later than the end-point of <CODE>?time-interval2.</CODE><BR>
<BR>
<LI><CODE>(finished-by ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial016.gif"><BR>
The end-point of <CODE>?time-interval1</CODE> is
 simultaneous with the end-point of <CODE>?time-interval2</CODE>, but
 the start-point of <CODE>?time-interval1</CODE> is
 earlier than the start-point of <CODE>?time-interval2.</CODE></UL>
The thirteenth Allen primitive is the equality relation for time intervals.
<UL><LI>
<CODE>(cotemporal ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
<IMG SRC="tutorial017.gif"><BR>
The start- and end-points of <CODE>?time-interval1</CODE>
 and <CODE>?time-interval2</CODE> are respectively simultaneous. The relation is
 also called <TT>temporal</TT>-<TT>bounds</TT>-<TT>identical</TT>.
</UL>
As with the relations on time points, the Allen primitives are mutually
exclusive and exhaustive: between any two time intervals, precisely one of
these relations holds. Again, the relation <CODE>cotemporal</CODE>
behaves like equality on time intervals for temporal reasoning, but it is not
a true equality relation. In particular, it is possible for a non-temporal
relation to be true for one time interval but false for another cotemporal
one; two time-intervals can be cotemporal without being equal.<BR>
<BR>
As with time points, <FONT COLOR=navy>SNARK</FONT>  can efficiently draw conclusions about time
intervals from assertions expressed in terms of the Allen
primitives. For example, suppose <CODE>time-interval1</CODE> <TT>meets</TT>
<CODE>time-interval2</CODE>, which in turn <TT>contains</TT> <CODE>time-interval3</CODE>.
The situation is illustrated as follows:<BR>
<BR>
<IMG SRC="tutorial018.gif"><BR>
<BR>
Then
<FONT COLOR=navy>SNARK</FONT>  can deduce that <CODE>time-interval1</CODE> is before <CODE>time-interval3</CODE>.<BR>
<BR>
Note that if one time interval <TT>meets</TT> another, the end-point of the first
interval must be <TT>simultaneous-with</TT> the start-point of the second.
Because <FONT COLOR=navy>SNARK</FONT>  doesn't identify a time interval with a set of points, it is
not meaningful to ask whether that time point is a member of either interval,
or whether those intervals have a point in common.<BR>
<BR>
<!--TOC subsubsection Nonprimitive Relations-->

<H4><A NAME="htoc50">6.2.2</A>&nbsp;&nbsp;Nonprimitive Relations</H4><!--SEC END -->

<A NAME="subsubsec-nonallen-temporal"></A>
There are relations between time intervals other than the thirteen Allen
primitives in <FONT COLOR=navy>SNARK</FONT>. The ones listed here are defined as disjunctions of
the Allen primitives, and hence are not logically necessary. However, they
provide a useful and convenient abbreviation for commonly used notions; we
used them in our HPKB work. The names are obtained from the CYC ontology
[<CITE><A HREF="#cyc">Lenat</A></CITE>].
<UL><LI>
 <CODE>(temporally-subsumes ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if <CODE>?time-interval2</CODE> is a (not necessarily strict) subinterval of
<CODE>?time-interval1</CODE>, that is, if any of the following conditions holds:
<PRE>
  (finished-by ?time-interval1 ?time-interval2)
  (contains ?time-interval1 ?time-interval2)
  (cotemporal ?time-interval1 ?time-interval2)
  (started-by ?time-interval1 ?time-interval2)
</PRE>In other words, it is defined as the disjunction of <CODE>finished-by</CODE>,
 <CODE>con</CODE><TT>tains</TT>, <CODE>cotemporal</CODE>, and <CODE>started-by</CODE>.<BR>
<BR>
<LI><CODE>(temporally-subsumed-by ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
The inverse of <TT>temporally-subsumes</TT>, it holds if <TT>?time-interval1</TT>
 is a subinterval of <TT>?time-interval2</TT>. It is
 defined as the disjunction of <TT>starts</TT>, <TT>cotemporal</TT>, <TT>during</TT>,
 and <TT>finishes</TT>, the inverses of the Allen primitives in the definition
 of <TT>temporally-subsumes</TT>.<BR>
<BR>
<LI><CODE>(starts-during ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if the start-point of <CODE>?time-interval1</CODE> is (strictly) during
 <CODE>?time</CODE>-<TT>interval2</TT>. It is defined as the disjunction of
 <CODE>during</CODE>, <CODE>finishes</CODE> and <TT>overlapped-by</TT>.<BR>
<BR>
<LI><CODE>(ends-during ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if the end-point of <TT>?time-interval1</TT> is during <TT>?time-interval2</TT>. If is defined as the disjunction of <TT>overlaps</TT>, <TT>starts</TT>, and <TT>during</TT>.<BR>
<BR>
<LI><CODE>(starts-after-starting-of ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if the start-point of <TT>?time-interval1</TT> is later than the
 start-point of <TT>?time-interval2</TT>. If is defined to be the disjunction
 of <TT>during</TT>, <TT>finishes</TT>, <TT>overlapped-by</TT>, <TT>met-by</TT>, and <TT>after</TT>.<BR>
<BR>
<LI><CODE>(ends-after-ending-of ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if the end-point of <TT>?time-interval1</TT> is later than the end-point
 of <TT>?time-interval2</TT>. It is defined to be the disjunction of <TT>contains</TT>, <TT>started-by</TT>, <TT>overlapped-by</TT>, <TT>met-by</TT>, and <TT>after</TT>.<BR>
<BR>
<LI><CODE>(ends-after-starting-of ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if the end-point of <TT>?time-interval1</TT> is later than the start-point
 of <TT>?time-interval2</TT>. It is defined to be the disjunction of all the
 Allen primitives except <TT>before</TT> and <TT>meets</TT>.<BR>
<BR>
<LI><CODE>(temporally-cooriginating ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if the start-points of <TT>?time-interval1</TT> and <TT>?time-interval2</TT> are simultaneous. It is defined to be the disjunction of
 <TT>starts</TT>, <TT>cotemporal</TT>, and <TT>started-by</TT>.<BR>
<BR>
<LI><CODE>(temporally-coterminal ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if the end-points of <TT>?time-interval1</TT> and <TT>?time-interval2</TT> are simultaneous. It is defined to be the disjunction of
 <TT>finishes</TT>, <TT>cotemporal</TT>, and <TT>finished-by</TT>.<BR>
<BR>
<LI><CODE>(temporally-disjoint ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if <TT>?time-interval1</TT> and <TT>?time-interval2</TT> have no interior
 points in common. It is defined to be the disjunction of the Allen
 primitives <TT>before</TT>, <TT>meets</TT>, <TT>met-by</TT>, and <TT>after</TT>.<BR>
<BR>
<LI><CODE>(temporally-intersects ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
Holds if <TT>?time-interval1</TT> and <TT>?time-interval2</TT> are not disjoint, i.e., if they have some interior points
 in common. It is defined to be the disjunction of
 all the Allen primitives except those in the definition of <TT>disjoint</TT>.
 It is also called <TT>temporal-bounds-intersect</TT>.</UL>
<!--TOC subsection Intermixing Temporal and Relational Reasoning-->

<H3><A NAME="htoc51">6.3</A>&nbsp;&nbsp;Intermixing Temporal and Relational Reasoning</H3><!--SEC END -->

<A NAME="subsec-temporal-relational"></A>
While it may be interesting to infer facts about temporal points and
intervals, the primary reason for including temporal reasoning in <FONT COLOR=navy>SNARK</FONT>  is
to allow us to combine reasoning about temporal and other relations to
describe a changing world. In particular, we want to be able to talk about
relations that are true at some times and false at others. One way to do
this is to allow those relations to have arguments that are time points or
time intervals. For example, we might introduce a relation
<PRE>
  (possesses ?person ?object ?time-point)
</PRE>to mean the <CODE>?person</CODE> owns <CODE>?object</CODE> at <CODE>?time-point</CODE>,
and
<PRE>
  (possesses ?person ?object ?time-interval)
</PRE>to mean the <CODE>?person</CODE> owns <CODE>?object</CODE> during <CODE>?time-interval</CODE>.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  allows any relation to have arguments that are
time intervals or time points, but that is not necessarily interpreted to
 mean that the relation is true at that time point or during that time
 interval. For instance, we might introduce a relation
<PRE>
  (hour-long ?time-interval)
</PRE>to mean that <TT>?time-interval</TT> is an hour long, not to mean that some
relation <TT>hour-long</TT> is true during <TT>?time-interval</TT>.<BR>
<BR>
Furthermore, <FONT COLOR=navy>SNARK</FONT>  does not assume that, if a relation holds for a time
interval, it necessarily holds for any of the time points that occur during
that interval, or for its end-points. Nor does it mean that the relation
holds for any subinterval of that interval.
 For instance, suppose the relation
<PRE>
  (profitable ?company ?time-interval)
</PRE>holds if <TT>?company</TT> makes a profit over the period <CODE>?time-interval</CODE>.
 But that does not necessarily imply that <TT>?company</TT> makes a profit over
 every subinterval of <TT>?time-interval</TT>. For instance, a company can be
 profitable over a year but have lost money for the first quarter of that
 year.<BR>
<BR>
Let us say that a relation is <EM>inherited by subintervals</EM> if, whenever it
 holds for a time interval, it holds for every subinterval of that interval.
 Thus, the relation <TT>possesses</TT> is inherited by subintervals but the
 relation <TT>profitable</TT> is not.
 <FONT COLOR=navy>SNARK</FONT> will not assume that a relation is inherited by subintervals unless
 we introduce an assertion that says so. To say that <TT>possesses</TT> is inherited by subintervals, we may introduce the assertion
<PRE>
  (assert
   '(implies
     (temporally-subsumes ?time-interval1 ?time-interval2)
     (implies
      (possesses ?person ?object ?time-interval1)
      (possesses ?person ?object ?time-interval2)))
   :name
    'possession-inherited-by-subintervals)
</PRE>
Now suppose we would like to say that George possessed the Maltese Falcon
during a certain period of time, say ``the good old days.'' Then we can
give the assertion
<PRE>
  (possesses george the-maltese-falcon good-old-days)
</PRE>Because <TT>possesses</TT> is inherited by subintervals, this will imply that
George possessed the Maltese Falcon during every subinterval of the good old
days.<BR>
<BR>
Now suppose we want to say that the good old days is the only time in which
George possessed the Falcon. To say this in terms of the Allen logic,
mentioning time intervals but not time points, we may say that George
did not possess the Falcon in any time interval other than the subintervals
of the good old days.
<PRE>
  (assert
   '(implies
     (not (temporally-subsumes good-old-days ?time-interval))
     (not (possesses george the-maltese-falcon ?time-interval)))
   :name 'george-does-not-possess-maltese-falcon-other-times)
</PRE>Then if a period of hard times
occurred later than the good old days, that is, if we have
<PRE>
  (assert '(before good-old-days hard-times)
          :name 'good-old-days-before-hard-times)
</PRE>then <FONT COLOR=navy>SNARK</FONT>  will be able to establish
<PRE>
  (prove
    '(not (possesses george the-maltese-falcon hard-times)))
</PRE>
<!--TOC subsection Mixed Point-Interval Relations-->

<H3><A NAME="htoc52">6.4</A>&nbsp;&nbsp;Mixed Point-Interval Relations</H3><!--SEC END -->

<A NAME="subsec-temporal-point-interval"></A>
We have talked about temporal relations between pairs of time points and
temporal relations between pairs of time intervals. In <FONT COLOR=navy>SNARK</FONT>  there are
also <EM>mixed</EM> temporal relations, between time points and time intervals
and between time intervals and time points. This is a useful extension of the
Allen temporal logic.<BR>
<BR>
The mixed relations have the same names as some of the point-point and
interval-interval relations. Their meanings are analogous.<BR>
<BR>
<!--TOC subsubsection Point-Interval Relations-->

<H4><A NAME="htoc53">6.4.1</A>&nbsp;&nbsp;Point-Interval Relations</H4><!--SEC END -->

Some of these mixed relations hold only between a time point and a time
interval, where the time point must be the first argument.
<UL><LI><CODE>(starts ?time-point ?time-interval)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is simultaneous with the start-point of
 <TT>?time</TT>-<TT>interval</TT>.<BR>
<BR>
<LI><CODE>(finishes ?time-point ?time-interval)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is simultaneous with the end-point of
 <TT>?time</TT>-<TT>interval</TT>.<BR>
<BR>
<LI><CODE>(during ?time-point ?time-interval)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is strictly between the start- and end-point of
 <TT>?time-interval</TT>.
</UL>
<!--TOC subsubsection Interval-Point Relations-->

<H4><A NAME="htoc54">6.4.2</A>&nbsp;&nbsp;Interval-Point Relations</H4><!--SEC END -->

The inverses of the point-interval relations hold only between an interval
and a point, where the point must be the second argument.
<UL><LI><CODE>(started-by ?time-interval ?time-point)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is simultaneous with the start-point of <TT>?time</TT>-<TT>interval</TT>.<BR>
<BR>
<LI><CODE>(finished-by ?time-interval ?time-point)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is simultaneous with the end-point of <TT>?time</TT>-<TT>interval</TT>.<BR>
<BR>
<LI><CODE>(contains ?time-interval ?time-point)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is strictly between the start- and end-points of
 <TT>?time</TT>-<TT>interval</TT>.</UL>
Of the mixed relations, <TT>before</TT> and <TT>after</TT> allow points and
intervals in either argument.

<UL><LI><CODE>(before ?time-point ?time-interval)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is strictly earlier
 than the start-point of <TT>?time</TT>-<TT>interval</TT>.<BR>
<BR>
<LI><CODE>(before ?time-interval ?time-point)</CODE>:<BR>
<BR>
Holds if the end-point of
 <TT>?time-interval </TT> is strictly earlier than <TT>?time</TT>-<TT>point</TT>.<BR>
<BR>
<LI><CODE>(after ?time-point ?time-interval)</CODE>:<BR>
<BR>
Holds if <TT>?time-point</TT> is strictly later than the end-point of
 <TT>?time</TT>-<TT>interval</TT>.<BR>
<BR>
<LI><CODE>(after ?time-interval ?time-point)</CODE>:<BR>
<BR>
Holds if the start-point of <TT>?time-interval</TT> is strictly later than
 <TT>?time</TT>-<TT>point</TT>.</UL>
Some of the temporal primitives have no corresponding mixed relations. The
equality relations <TT>cotemporal</TT> and <TT>simultaneous-with</TT> are not
defined on mixed arguments, because a time point can never be temporally
equal to a time interval. The relations <TT>meets</TT>, <TT>met-by</TT>, <TT>overlaps</TT>, and <TT>overlapped-by</TT> are not necessary for mixed arguments,
because the concepts they would stand for are either nonsensical or already
have other names. For instance, to say that a time point <TT>meets</TT> a time
interval would be equivalent to saying that it <TT>starts</TT> the time
interval. And it doesn't make sense for a time point to overlap a time
interval.<BR>
<BR>
<!--TOC subsubsection Nonprimitive mixed relations-->

<H4><A NAME="htoc55">6.4.3</A>&nbsp;&nbsp;Nonprimitive mixed relations</H4><!--SEC END -->

Some of the nonprimitive temporal relations can be used between an interval
and a point, or between a point and an interval, including
<UL><LI><CODE>(temporally-intersects ?time-interval ?time-point)</CODE>:<BR>
<BR>
<LI><CODE>(temporally-intersects ?time-point ?time-interval)</CODE>:<BR>
<BR>
These relations are inverses. Both hold if <TT>?time</TT>-<TT>point</TT>
 occurs, not necessarily strictly, in <TT>?time</TT>-<TT>interval</TT>. That is,
 <TT>?time-point</TT> is simultaneous with the start- or end-point of <TT>?time</TT>-<TT>interval</TT> or is between those two time-points.
</UL>
To summarize, a single Allen-style temporal reasoning system is used for all
relations among points and intervals.
<UL><LI>
 There are three exhaustive, mutually
exclusive relations between time points (<TT>simultaneous</TT>-<TT>with</TT>, <TT>before</TT>, and <TT>after</TT>).<BR>
<BR>
<LI>There are thirteen exhaustive, mutually exclusive relations between time
intervals, given in Section <A HREF="#subsubsec-allen-primitives">6.2.1</A>.<BR>
<BR>
<LI>There are five exhaustive, mutually exclusive relations between a time
point and a time interval (<TT>before</TT>, <TT>starts</TT>, <TT>during</TT>, <TT>finishes</TT>, and <TT>after</TT>), and their five inverses, which are relations
between a time interval and a time point (<TT>after</TT>, <TT>started-by</TT>, <TT>contains</TT>, <TT>finished-by</TT>, and <TT>before</TT>).
</UL>
Thus, all in all there are twenty-six primitive relations between temporal
entities.
<!--TOC subsection Temporal Functions-->

<H3><A NAME="htoc56">6.5</A>&nbsp;&nbsp;Temporal Functions</H3><!--SEC END -->

The temporal reasoning package defines functions that are useful for
mapping time intervals and time-points into others. They include
<UL><LI><CODE>(start-fn ?time-interval)</CODE>:<BR>
<BR>
The start-point of <TT>?time-interval</TT>.<BR>
<BR>
<LI><CODE>(end-fn ?time-interval)</CODE>:<BR>
<BR>
The end-point of <TT>?time</TT>-<TT>interval</TT>.<BR>
<BR>
<LI><CODE>(time-interval ?time-point1 ?time-point2)</CODE>:<BR>
<BR>
The time interval from <TT>?time</TT>-<TT>point1</TT> to <TT>?time</TT>-<TT>point2</TT>.
 That is, the start-point of the interval is <TT>?time</TT>-<TT>point1</TT> and the
 end-point is <TT>?time</TT>-<TT>point2</TT>. Here <TT>?time</TT>-<TT>point1</TT> must
 be before <TT>?time</TT>-<TT>point2</TT>.<BR>
<BR>
<LI><CODE>(time-interval-ip ?time-interval ?time-point)</CODE>:<BR>
<BR>
The time interval from the start-point of <TT>?time-interval</TT> to <TT>?time</TT>-<TT>point</TT>. It is assumed that the start-point
 is before <TT>?time</TT>-<TT>point</TT>.<BR>
<BR>
<LI><CODE>(time-interval-pi ?time-point ?time-interval)</CODE>:<BR>
<BR>
The time interval from <TT>?time</TT>-<TT>point</TT> to the end-point of <TT>?time</TT>-<TT>interval</TT>. It is assumed that <TT>?time</TT>-<TT>point</TT> is
 before the end-point.<BR>
<BR>
<LI><CODE>(time-interval-ii ?time-interval1 ?time-interval2)</CODE>:<BR>
<BR>
The time interval from the start-point of <TT>?time</TT>-<TT>interval1</TT> to the
 end-point of <TT>?time</TT>-<TT>interval2</TT>. It is assumed that the start-point
 comes before the end-point.</UL>
<!--TOC subsection Point-Interval Temporal and Relational Reasoning-->

<H3><A NAME="htoc57">6.6</A>&nbsp;&nbsp;Point-Interval Temporal and Relational Reasoning</H3><!--SEC END -->

<A NAME="subsec-mixed-temporal-relational"></A>
The reason to introduce the mixed point-interval temporal relations is that
reasoning about a changing world is more natural if we can talk about both
points and intervals. For instance, it made sense (in Section
<A HREF="#subsec-temporal-relational">6.3</A>) when we asserted that George possessed the
Maltese Falcon during the good old days, but it was a bit artificial when we
said that
 George did not possess the Falcon during any time interval not
temporally subsumed by the good old days.<BR>
<BR>
It might have been more natural to use mixed time intervals and time points
to express the same properties. For instance, let us say that a relation
is <EM>inherited by sub-points</EM> if, whenever that relation holds for a
time interval, it also holds for every time point that temporally intersects
that interval. Note that a relation may be inherited by subintervals, as
we discussed in <A HREF="#subsec-temporal-relational">6.3</A>, but not inherited by
sub-points, and vice versa.<BR>
<BR>
We can say that the relation <TT>possesses</TT> is inherited by
sub-points by introducing the assertion
<PRE>
  (assert
   '(implies
     (temporally-intersects ?time-interval ?time-point)
     (implies
      (possesses ?person ?object ?time-interval)
      (possesses ?person ?object ?time-point)))
   :name
   'possession-inherited-by-sub-points)
</PRE>And we can say further that George does not possess the Falcon at any time
point that does not occur during the good old days:
<PRE>
  (assert
   '(implies
     (not (temporally-intersects good-old-days ?time-point))
     (not (possesses george the-maltese-falcon ?time-point)))
   :name 'george-doesnt-possess-maltese-falcon-other-times
</PRE>And finally we can say that the special time point <TT>now</TT> is later than
the good old days:
<PRE>
  (assert '(before good-old-days now)
          :name 'good-old-days-before-now)
</PRE>Note that all these assertions use temporal relations between time intervals
and time points. From these assertions <FONT COLOR=navy>SNARK</FONT>  can establish
<PRE>
  (prove '(not (possesses george the-maltese-falcon now)))
</PRE>
<!--TOC subsection Calendar Dates and Clock Times-->

<H3><A NAME="htoc58">6.7</A>&nbsp;&nbsp;Calendar Dates and Clock Times</H3><!--SEC END -->

<FONT COLOR=navy>SNARK</FONT>  has a built-in representation of dates on the calendar and times on
the clock, and this representation is integrated into the temporal inference
procedure. For example, <FONT COLOR=navy>SNARK</FONT>  knows that December 31, 1999 meets January
1, 2000, in Allen's sense of ``meets'', and that 11PM on the former date is
before 1AM on the latter date.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>  supports the following date
functions, which are based on the Cyc ontology [<CITE><A HREF="#cyc-ul">Cyc-UL</A></CITE>].
<UL><LI><CODE>(year-fn ?integer)</CODE>:<BR>
<BR>
The time interval corresponding to the year <TT>?integer</TT>. For example, <TT>(year-fn 1999)</TT> is the time interval with start-point 00:00:00 hours on
January 1, 1999, and end-point 00:00:00 hours on January 1, 2000.<BR>
<BR>
<LI><CODE>(month-fn ?integer ?year)</CODE>:<BR>
<BR>
The time interval corresponding to the month numbered <TT>?integer</TT>, between
1 and 12; e. g., <TT>(month-fn 5 (year-fn 1999))</TT>. The month-fn function
also accepts the names of the months, e. g.&nbsp; <TT>(month-fn May (year-fn
1999))</TT>.<BR>
<BR>
<LI><CODE>(day-fn ?integer ?month)</CODE>:<BR>
<BR>
The time interval corresponding to the calendar day <TT>?integer</TT> of <TT>?month</TT>. For example, <TT>(day-fn 10 (month-fn 5 (year-fn 1999)))</TT>
represents the time interval corresponding to May 10, 1999. Here <TT>integer</TT> must be at least 1; no promises are
made about what happens if <TT>?integer</TT> is larger than the number of days in
the month.<BR>
<BR>
<LI><CODE>(hour-fn ?integer ?day)</CODE>:<BR>
<BR>
The time interval corresponding to the hour <TT>?integer</TT> of <TT>?day</TT>.
For example, <TT>(hour-fn 11 (day-fn 10 (month-fn 5 (year-fn 1999))))</TT>
represents the interval defined by 11:00 AM, May 10, 1999. <FONT COLOR=navy>SNARK</FONT>  uses a
24-hour day; <TT>?integer</TT> should be between 0 and 23. <FONT COLOR=navy>SNARK</FONT>  does not know
about time zones; all times should be in the same time zone, but it does not
matter which.<BR>
<BR>
<LI><CODE>(minute-fn ?integer ?hour)</CODE>:<BR>
<BR>
The time interval corresponding to the minute <TT>?integer</TT> of <TT>?hour</TT>,
where <TT>?integer</TT> is between 0 and 59.
For example, <TT>(minute-fn 12 (hour-fn 11 (day-fn 10 (month-fn 5 (year-fn
1999)))))</TT> represents the interval defined by 11:12 AM, May 10, 1999. The
interval starts at 12 minutes after the hour, and continues until 13 minutes
after the hour.<BR>
<BR>
<LI><CODE>(second-fn ?integer ?minute)</CODE>:<BR>
<BR>
The time interval corresponding to the second numbered <TT>?integer</TT> of <TT>?minute</TT>, where <TT>?integer</TT> is between 0 and 59. For example, <TT>(second-fn 13 (minute-fn 12 (hour-fn 11 (day-fn 10 (month-fn 5 (year-fn
1999))))))</TT> represents the interval starting 11:12:13 A.M., May 10, 1999 and
continuing until 11:12:14 on the same day.
</UL>
<!--TOC subsection Dates in Other Time Intervals-->

<H3><A NAME="htoc59">6.8</A>&nbsp;&nbsp;Dates in Other Time Intervals</H3><!--SEC END -->

It is quite common to specify dates in a non-calendar time interval; for
example, ``The President made a statement on the third day of the war.''
<FONT COLOR=navy>SNARK</FONT>  supports such reasoning by an extension of the function <TT>day-fn</TT>,
described as follows:
<UL><LI>
 <CODE>(day-fn ?integer ?constant)</CODE>:<BR>
<BR>
The fifth day of the time interval corresponding to <TT>?constant</TT>. For
example, <TT>(day-fn 5 scenario)</TT> represents the fifth day in <TT>scenario</TT>. It is understood that <TT>scenario</TT> is supposed to correspond to
a time interval, but <FONT COLOR=navy>SNARK</FONT>  does not enforce that. The date reasoning
procedure is unable to compare dates between two different non-calendar time
intervals, even if temporal relations are known between the two intervals.
For instance, even if we assert <TT>(before the-civil-war
the-age-of-aquarius)</TT>, <FONT COLOR=navy>SNARK</FONT>  will not know that <TT>(before (day-fn 1
the-civil-war) (day-fn 2 the-age-of-aquarius))</TT>.</UL>
<!--TOC subsection Temporal Reasoner Interface-->

<H3><A NAME="htoc60">6.9</A>&nbsp;&nbsp;Temporal Reasoner Interface</H3><!--SEC END -->

The interface between <FONT COLOR=navy>SNARK</FONT>  and the Allen temporal-reasoning procedure uses
constraint resolution [<CITE><A HREF="#burckert">Burckert</A></CITE>]. Each row is split between ;<BR>
<BR>
If a pure temporal relation between two ground (i. e., variable-less) terms is
asserted or deduced, it is introduced into a graph representation of all
known temporal relations. If the relation already follows from the relations
in the graph, the graph is not changed. If the relation contradicts what is
already known in the graph, a contradiction has been deduced and the proof is
complete.<BR>
<BR>
If a more complex formula is asserted of deduced, it is split between a
logical part and a temporal constraint, which are kept in the same row.
The constrained row means that if
some instance of the temporal constraint is satisfied, the corresponding
instance of the logical part is true.<BR>
<BR>
For example, suppose a proof contains the row
<PRE>
(Row 137
   (possesses george the-maltese-falcon ?time-interval)
   Temporal-Constraint
    (ii%temporally-subsumes good-old-days ?time-interval)).
</PRE>Here <CODE>ii%temporally-subsumes</CODE> is the graph representation of the relation
<TT>temporally-subsumes</TT>. This row means that if the good-old-days interval
temporally subsumes <TT>?time-interval</TT>, then George possesses the Maltese
Falcon during <TT>?time-interval</TT>.<BR>
<BR>
Deduction rules applied to constrained rows generate a new row, which
contains both a logical part and a temporal constraint.
 When the temporal constraint is ground, the graph representation of all known
temporal constraints is used to see if the constraint is satisfied; if so,
the constraint is removed. If the constraint contradicts the known temporal
relationships, the entire row is discarded.<BR>
<BR>
The link between the Allen relations that appear in formulas and their
corresponding graph representations is achieved by a number of assertions
that are added automatically by <FONT COLOR=navy>SNARK</FONT>. For example:
<PRE>
(Row ~ii%temporally-subsumes
   (not (temporally-subsumes ?time-interval ?time-interval1))
   assertion
   Temporal-Constraint
    (not
     (ii%temporally-subsumes ?time-interval ?time-interval1))).
</PRE>This asserts that if the graph representation of the relation <TT>temporally</TT>-<TT>subsumes</TT> is satisfied, the relation itself holds. Applying
the resolution rule to this assertion and a formula that mentions the
relation will have the effect of removing the relation from the formula and
adding it to the temporal constraint.<BR>
<BR>
The proof is complete when <FONT COLOR=navy>SNARK</FONT>  has discovered a contradiction in the
logical parts of the rows, and when the corresponding temporal constraints
are also satisfied. Should <FONT COLOR=navy>SNARK</FONT>  deduce a contradictory row <TT>false</TT>
whose corresponding temporal constraints cannot be satisfied, the row is
discarded and the search continues.<BR>
<BR>
<!--TOC section Procedural Attachment-->

<H2><A NAME="htoc61">7</A>&nbsp;&nbsp;Procedural Attachment</H2><!--SEC END -->

<A NAME="sec-procedural-attachment"></A>
We have seen that, for some areas such as temporal reasoning, it is
advantageous to use special-purpose inference procedures rather than to rely
on only <FONT COLOR=navy>SNARK</FONT>'s general-purpose inference rules. It is impossible,
however, for <FONT COLOR=navy>SNARK</FONT>  to include every special-purpose procedure that may be
useful for some application. Instead, <FONT COLOR=navy>SNARK</FONT>  includes a procedural
attachment facility that allows a user to invoke external procedures as part
of the standard resolution.<BR>
<BR>
There are two principal ways to introduce procedural attachments, by
intervening in either the rewriting mechanism or the resolution mechanism.
We treat each separately. (There is also a way to use procedural attachment
via the paramodulation rule.)<BR>
<BR>
<!--TOC subsection Rewrite Code-->

<H3><A NAME="htoc62">7.1</A>&nbsp;&nbsp;Rewrite Code</H3><!--SEC END -->

<A NAME="subsec-rewrite-code"></A>
The rewrite-code mechanism allows the user to provide external code to
rewrite expressions, much as a rewrite rule does. This code is
associated with particular function or predicate symbols.<BR>
<BR>
<!--TOC subsubsection Built-in Rewrite Code-->

<H4><A NAME="htoc63">7.1.1</A>&nbsp;&nbsp;Built-in Rewrite Code</H4><!--SEC END -->

<FONT COLOR=navy>SNARK</FONT>  already has built-in procedural attachments, in the form of rewrite
code, for important arithmetical, symbolic, and list-processing functions.
For instance, if there were no procedural attachment mechanism, the only way
we would be able to add two numbers would be to reason from the axioms for
addition, a rather ponderous business. However,
if we select the option <TT>use</TT>-<TT>code</TT>-<TT>for</TT>-<TT>numbers</TT>, arithmetic operations will be carried out by the corresponding
<FONT COLOR=navy>LISP</FONT>  code. In particular, a term <CODE>(+ 2 2)</CODE> will be immediately
rewritten as <TT>4</TT>, without invoking any axioms or inference rules.
<FONT COLOR=navy>SNARK</FONT>  has procedural attachments for the principal arithmetic function and
predicate symbols in the <FONT COLOR=navy>ANSI  KIF  COMMON LISP</FONT>  library. Similarly,
selecting the options <TT>use</TT>-<TT>code</TT>-<TT>for</TT>-<TT>lists</TT> and <TT>use</TT>-<TT>code</TT>-<TT>for</TT>-<TT>characters</TT> will give <FONT COLOR=navy>SNARK</FONT>  access to
 <FONT COLOR=navy>ANSI  KIF  COMMON LISP</FONT>'s list and character libraries.<BR>
<BR>
The <FONT COLOR=navy>SNARK</FONT>  equality function is also rewritten by a built-in procedural
attachment. For instance, a formula of form <CODE>(= &lt;term&gt; &lt;term&gt;)</CODE>, where both
arguments are alike, will be automatically rewritten to <TT>true</TT>.<BR>
<BR>
A procedure can be attached to a user-defined <FONT COLOR=navy>SNARK</FONT>  function or predicate
symbol by means of its declaration. Some built-in procedures can be attached
to user-defined symbols. For example, suppose we wish to declare that the
relation <TT>near</TT> is reflexive, that is, that a place is to be regarded as
near to itself. Then we may include the declaration
<PRE>
  (declare-predicate-symbol
    'near 2 :rewrite-code 'reflexivity-rewriter)
</PRE>in addition to whatever other declarations are given for the predicate symbol
<TT>near</TT>. The program <TT>reflexivity-rewriter</TT> is <FONT COLOR=navy>LISP</FONT>  code built into
<FONT COLOR=navy>SNARK</FONT>  that performs a rewriting analogous to the one we have described for
equality. In using this rewriting in the course of a proof, <FONT COLOR=navy>SNARK</FONT>  will
report <TT>rewrite</TT> ...<TT>:code</TT>-<TT>for</TT>-<TT>near</TT> in the
explanation.<BR>
<BR>
<!--TOC subsubsection User-Supplied Rewrite Code-->

<H4><A NAME="htoc64">7.1.2</A>&nbsp;&nbsp;User-Supplied Rewrite Code</H4><!--SEC END -->

 Let us look at the program <TT>reflexivity-rewriter</TT> described in the
previous section; then we can describe the constructs necessary to understand
it and to build analogous rewrite code for our own theories.
<PRE>
(defun REFLEXIVITY-REWRITER (atom subst)
  (let ((args (args atom)))
    (if (equal-p (first args) (second args) subst) true none)))
</PRE>
This program tests if, after applying the substitution <TT>subst</TT>, the two
arguments of the formula <TT>atom</TT> are equal; if so, it returns <TT>true</TT>;
otherwise, it returns the special symbol <TT>:none</TT>, which indicates that
the formula is not to be rewritten. (The <FONT COLOR=navy>LISP</FONT>  variable <TT>none</TT>
has value <TT>:none</TT>.)<BR>
<BR>
Every piece of rewrite code has two arguments, an expression and a
substitution, here called <TT>atom</TT> and <TT>subst</TT> respectively.
The actual expression being simplified is the result of applying <TT>subst</TT>
to <TT>atom</TT>. For example, if <TT>atom</TT> is <CODE>(near ?place ohio)</CODE>
and <TT>subst</TT> is a substitution that replaces <TT>?place</TT> with <TT>ohio</TT>,
the actual expression being substituted is <CODE>(near ohio ohio)</CODE>. For
reasons of efficiency, <FONT COLOR=navy>SNARK</FONT>  sometimes
carries around the substitution rather than applying it.<BR>
<BR>
The following <FONT COLOR=navy>LISP</FONT>  functions are defined in <FONT COLOR=navy>SNARK</FONT>  and are useful for
writing procedural attachments.
<DL COMPACT=compact><DT><DD><TT>:none</TT>:<BR>
<BR>
As mentioned above, a special symbol that can be returned by a rewrite rule to
 indicate that the expression is not to be rewritten by that rule. The
 <FONT COLOR=navy>LISP</FONT>  variable <TT>none</TT> is assigned the value <TT>:none</TT>.<BR>
<BR>
<DT><DD><CODE>(head exp)</CODE>:<BR>
<BR>
The principal function or predicate symbol of the expression <TT>exp</TT>.<BR>
<BR>
<DT><DD><CODE>(args exp)</CODE>:<BR>
<BR>
The argument list of the expression <TT>exp</TT>.<BR>
<BR>
<DT><DD><CODE>(equal-p exp1 exp2 subst)</CODE>:<BR>
<BR>
A test which is true if applying the substitution <TT>subst</TT> to the
 expressions <TT>exp1</TT> and <TT>exp2</TT> yields identical expressions, false
 otherwise.
</DL>
A more complex construct is
<PRE>
  (dereference exp subst
    :if-constant const-code
    :if-variable var-code
    :if-compound comp-code)
</PRE>The construction applies the substitution <TT>subst</TT> to the expression <TT>exp</TT> and evaluates <TT>exp</TT>. Then
<DL COMPACT=compact><DT><DD> If the result is a constant, it evaluates the <FONT COLOR=navy>LISP</FONT>
 expression <TT>const-code</TT>.<BR>
<BR>
<DT><DD> If the result is a variable, it evaluates the <FONT COLOR=navy>LISP</FONT>
 expression <TT>var-code</TT>.<BR>
<BR>
<DT><DD> If the result is a compound expression, such as the
 application of a function symbol to arguments, it evaluates the <FONT COLOR=navy>LISP</FONT>
 expression <TT>comp-code</TT>.</DL>

In each case, the value of the entire <TT>dereference</TT> expression is the
 value of the evaluated subexpression. Any of the keyword cases can be
 omitted, and their order is inconsequential. In case none of the given
 keywords is applicable, the value of the <TT>dereference</TT> expression is
 <TT>nil</TT>.<BR>
<BR>
<!--TOC subsubsection Example: Rewrite Code for <TT>mother</TT>-->

<H4><A NAME="htoc65">7.1.3</A>&nbsp;&nbsp;Example: Rewrite Code for <TT>mother</TT></H4><!--SEC END -->

Let us use some of these constructs in the family theory to introduce rewrite
code for the function <TT>mother</TT>. Suppose there is a <FONT COLOR=navy>LISP</FONT>  function <TT>mother-fun</TT> that can compute the mother of any constant of sort <TT>person</TT>;
for instance, <TT>mother-fun</TT> might consult external genealogical tables for
this purpose. We would like to attach this program to the function symbol
<TT>mother</TT> in our family theory.<BR>
<BR>
First we indicate that the symbol <TT>mother</TT> is to be given a procedural
attachment in the form of rewrite code.
<PRE>
  (declare-function-symbol 'mother 1
                           :rewrite-code 'mother-rewriter)
</PRE>Then we define the <FONT COLOR=navy>LISP</FONT> function <TT>mother-rewriter</TT>
 to extract the argument <TT>arg</TT> from terms of form <CODE>(mother arg)</CODE>,
 where <TT>arg</TT> is a constant, and to invoke <TT>mother-fun</TT> on that
 constant:
<PRE>
  (defun MOTHER-REWRITER (term subst)
    (let ((child (first (args term))))
      (dereference child subst
                   :if-constant
                   (mother-fun child)
                   :if-variable none
                   :if-compound none)))
</PRE>Note that this will have no effect on terms of form <CODE>(mother arg)</CODE>,
where <TT>arg</TT> is a variable or a compound term. Also, we are assuming that
all the constant symbols returned by <TT>mother</TT>-<TT>fun</TT> have already been
declared to be of sort <TT>woman</TT> (and hence <TT>person</TT>); if new names are
introduced by <TT>mother</TT>-<TT>fun</TT>, they must be declared by <TT>mother</TT>-<TT>rewriter</TT>. For example, the preceding <FONT COLOR=navy>LISP</FONT>  function might be
revised to include the expression
<PRE>
  (declare-constant-symbol (mother-fun child) :sort 'woman)
</PRE>
Given this procedural attachment, <FONT COLOR=navy>SNARK</FONT>  can answer queries such as
<PRE>
  (prove
   '(and (= ?woman (mother ?person))(parent ?person carol))
   :answer '(ans ?woman))
</PRE>where all the information it has about the mothers of individual constants is
given by the function <TT>mother-fun</TT>. <FONT COLOR=navy>SNARK</FONT>  will behave as if all this
information were stored as rewrite rules. For instance, suppose
<PRE>
  (mother-fun carol) = betty
</PRE>and
<PRE>
  (mother-fun betty) = alice
</PRE>Then <FONT COLOR=navy>SNARK</FONT>  will include <TT>alice</TT> among its answers for the above query.
Use of <TT>mother-fun</TT> in the proof will be justified by the annotation
 <TT>rewrite</TT> ...<TT>:code</TT>-<TT>for</TT>-<TT>mother</TT> in the explanation.<BR>
<BR>
Procedural attachments can coexist with axioms. Thus, we might have axioms
about <TT>mother-fun</TT> as well as the procedural attachment.<BR>
<BR>
<!--TOC subsection Satisfy and Falsify Code-->

<H3><A NAME="htoc66">7.2</A>&nbsp;&nbsp;Satisfy and Falsify Code</H3><!--SEC END -->

The same limitations that apply when information is represented by rewrite
rules also applies when information is stored in rewrite code. For instance,
we cannot use the rewrite code for mother to answer the query
<PRE>
  (prove
   '(= betty (mother ?person))
   :answer '(ans ?person)
   :name 'whose-mother-is-betty?)
</PRE>Although the procedural attachment can rewrite <CODE>(mother carol)</CODE> to <TT>betty</TT>, it has no effect on the term <CODE>(mother ?person)</CODE>. In fact,
because of the one-way nature of a function, we cannot use a procedural
attachment to a function symbol to answer this kind of question. We can,
however, use the <EM>satisfy-</EM> and <EM>falsify-code</EM> mechanisms, which
allow a procedural attachment to intervene in the resolution mechanism. We
introduce these with an example.<BR>
<BR>
<!--TOC subsubsection Satisfy Code for mother-->

<H4><A NAME="htoc67">7.2.1</A>&nbsp;&nbsp;Satisfy Code for mother</H4><!--SEC END -->

Suppose that, in addition to the <TT>mother</TT> function symbol, we also
introduce a two-place <TT>mother</TT> predicate symbol. Imagine that we have a
table of mother-child pairs, e.g.,
<PRE>
  (defvar MOTHER-TABLE
    '((alice betty)
      (alice barbara)
      (betty carol)
      (betty claudia)
      ))
</PRE>In other words, Alice is the mother of Betty, Alice is the mother of Barbara,
and so forth. Then we can use the satisfy-code mechanism to make <FONT COLOR=navy>SNARK</FONT>
behave as if it had been given the corresponding atomic assertions
<PRE>
  (assert '(mother alice betty))

  (assert '(mother alice barbara))

  (assert '(mother betty carol))

  (assert '(mother betty claudia))
</PRE>We do this by attaching to the predicate symbol <TT>mother</TT> a procedure
that, whenever <FONT COLOR=navy>SNARK</FONT> is trying to establish the truth of a formula of form
<TT>(mother person1 person2)</TT>, will cycle through
 <TT>mother</TT>-<TT>table</TT> and attempt to unify the pair
<CODE>(person1 person2)</CODE> with successive pairs of the table.<BR>
<BR>
First we indicate that the predicate symbol <TT>mother</TT> is given a
procedural attachment in the form of satisfy code:
<PRE>
  (declare-predicate-symbol 'mother 2
    :satisfy-code 'mother-satisfier)
</PRE>Then we provide a <FONT COLOR=navy>LISP</FONT>  function <TT>mother</TT>-<TT>satisfier</TT> that will
attempt to unify the arguments of the formula against the successive pairs
of the table:
<PRE>
  (defun MOTHER-SATISFIER (cc atom subst)
    (let ((args (args atom)))
      (mapc
       (lambda (pair) (unify cc args pair subst))
       mother-table)))
</PRE>Here each pair in <TT>mother</TT>-<TT>table</TT> is unified with the pair of
arguments of the formula under consideration. Note that <TT>mother</TT>-<TT>satisfier</TT>, like all satisfy code, has a continuation <TT>cc</TT> as its first
argument. The continuation is a function that, when called, will attempt to
complete the rest of the proof. If <TT>unify</TT> succeeds in unifying <TT>args</TT> with <TT>pair</TT>, it will then invoke the continuation <TT>cc</TT>, passing
on whatever substitutions <TT>unify</TT> has discovered.<BR>
<BR>
Once we have provided this procedural attachment, <FONT COLOR=navy>SNARK</FONT>  can use the table
to provide answers to the query
<PRE>
  (prove
   '(mother betty ?person)
   :answer '(ans ?person)
   :name 'who-is-bettys-child?)
</PRE>Invoking this query once will provide one answer, Carol. Then executing
<CODE>(closure)</CODE> will send <FONT COLOR=navy>SNARK</FONT>  back into the table to find another
answer, Claudia.<BR>
<BR>
While introducing a procedural attachment for such a small table gives no
benefit, it is reasonable to introduce procedural attachments for large
tables and it is unavoidable if the table can only be accessed via an
external function call or a web access.<BR>
<BR>
<!--TOC subsubsection Falsify code for <TT>mother</TT>-->

<H4><A NAME="htoc68">7.2.2</A>&nbsp;&nbsp;Falsify code for <TT>mother</TT></H4><!--SEC END -->

Satisfy code allows us to establish that a relation is true as the result of
executing a procedure. Sometimes, however, a procedure can tell us that the
relation is false. To invoke such a procedure, we use <EM>falsify code</EM>.<BR>
<BR>
For instance, suppose we want to introduce code to embody the idea that the
relation <TT>mother</TT> is irreflexive, i.  e., that a person cannot be her own
mother. One could do this by introducing an assertion
<PRE>
  (assert
   '(not (mother ?person ?person))
   :name 'mother-is-irreflexive)
</PRE>Alternatively, we can introduce falsify code to have the same effect as
resolution against the above assertion.<BR>
<BR>
For this purpose, we declare the predicate symbol <TT>mother</TT> to have
falsify code <TT>mother-falsifier</TT>:
<PRE>
  (declare-predicate-symbol 'mother 2
    :falsify-code 'mother-falsifier)
</PRE>Note that the same symbol can have satisfy code, falsify code, and rewriting
code.<BR>
<BR>
We define the <FONT COLOR=navy>LISP</FONT>  function <TT>falsify-code</TT> as
<PRE>
  (defun MOTHER-FALSIFIER (cc atom subst)
    (let ((args (args atom)))
      (unify cc (first args) (second args) subst)))
</PRE>Here, again, <TT>cc</TT> is continuation code that attempts to complete the
proof.
This function will be invoked when a formula <TT>(mother person1 person2)</TT>
occurs in a context in which we are trying to prove that it is false, e.  g.,
in a query of form
<PRE>
  (prove
   '(not (mother person1 person2)))
</PRE>where <TT>person1</TT> and <TT>person2</TT> are terms that may have variables. It
will attempt to unify <TT>person1</TT> and <TT>person2</TT>. If it succeeds, <TT>unify</TT> will call the continuation code <TT>cc</TT>, passing on whatever
substitutions it has discovered, in an attempt to complete the proof. If
<TT>unify</TT> fails, <TT>mother</TT>-<TT>falsify</TT> returns and other avenues to
complete the proof are sought.<BR>
<BR>
Actually, <FONT COLOR=navy>SNARK</FONT>  has general-purpose code for declaring a relation to be
irreflexive and introducing the appropriate falsify code. So, to declare
the predicate <TT>mother</TT> to be irreflexive, we could obtain the same effect
simply by introducing the declaration
<PRE>
  (declare-predicate-symbol 'mother 2
    :falsify-code 'irreflexivity-falsifier)
</PRE>
<!--TOC section Support for <FONT COLOR=navy>KIF</FONT>/<FONT COLOR=navy>OKBC</FONT>  Users-->

<H2><A NAME="htoc69">8</A>&nbsp;&nbsp;Support for <FONT COLOR=navy>KIF</FONT>/<FONT COLOR=navy>OKBC</FONT>  Users</H2><!--SEC END -->

<A NAME="sec-kif-snark"></A>
Knowledge Interchange Format (<FONT COLOR=navy>KIF</FONT>  ) is a language designed for use in
the interchange of knowledge amongst disparate computer systems
[<CITE><A HREF="#kif">Genesereth</A></CITE>]. <FONT COLOR=navy>KIF</FONT>  was a result of a community effort and a draft of the
<FONT COLOR=navy>KIF</FONT>  specification is under consideration as an <FONT COLOR=navy>ANSI</FONT>  standard. Open
Knowledge Base Connectivity (<FONT COLOR=navy>OKBC</FONT>) is an application programming
interface for accessing knowledge representation systems. <FONT COLOR=navy>OKBC</FONT>  interfaces
to many popular knowledge representation systems exist.<BR>
<BR>
Given such a broad base of <FONT COLOR=navy>KIF</FONT>  and <FONT COLOR=navy>OKBC</FONT>  users, <FONT COLOR=navy>SNARK</FONT>  supports input
of axioms in a language called <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>(``<FONT COLOR=navy>KIF</FONT>  plus
Classes''). <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  uses the <FONT COLOR=navy>ANSI</FONT>  draft <FONT COLOR=navy>KIF</FONT>  syntax for writing
axioms, and recognizes some standard relation names from the <FONT COLOR=navy>OKBC</FONT>
knowledge model.<BR>
<BR>
The <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  not only makes it easier for <FONT COLOR=navy>SNARK</FONT>  to do knowledge
sharing with other systems, but also implements a connection between
three ways of representing classes of entities in
<FONT COLOR=navy>SNARK</FONT>: through sorts, through sets, and through predicate symbols. In
this section we introduce this way of presenting information to <FONT COLOR=navy>SNARK</FONT>.<BR>
<BR>
<!--TOC subsection Introduction to <FONT COLOR=navy>KIF</FONT>-->

<H3><A NAME="htoc70">8.1</A>&nbsp;&nbsp;Introduction to <FONT COLOR=navy>KIF</FONT></H3><!--SEC END -->

<FONT COLOR=navy>KIF</FONT>  has declarative semantics, is logically comprehensive with its
support for arbitrary logical sentences, and supports representation
of knowledge about knowledge.<BR>
<BR>
<FONT COLOR=navy>KIF</FONT>  accepts sentences built up of constants, function and predicate symbols,
logical connectives, and quantifiers. <FONT COLOR=navy>KIF</FONT>  accepts the equality
symbol <CODE>=</CODE>, the connectives <CODE>and</CODE>, <CODE>or</CODE>, <CODE>not</CODE>,
and the quantifiers <CODE>forall</CODE> and <CODE>exists</CODE>.<BR>
<BR>
Function and relation symbol may occur with different arities.
<FONT COLOR=navy>KIF</FONT> assumes that if the same symbol occurs with varying arity, all those
occurrences stand for the same function, and the function itself has
variable arity.<BR>
<BR>
<FONT COLOR=navy>KIF</FONT>  has three directions of implication connective, <CODE>=&gt;</CODE>, <CODE>&lt;=</CODE>
and <CODE>&lt;=&gt;</CODE>.<BR>
<BR>
Free variables in assertions have tacit universal quantification,
while free variables in queries have tacit existential quantification.<BR>
<BR>
<FONT COLOR=navy>KIF</FONT>  has four constructs for defining new symbols:
<DL COMPACT=compact><DT>
 <B>defobject</B><DD> Introduces a new constant, standing for a thing or entity.<BR>
<BR>
<DT><B>defrelation</B><DD> Introduces a new predicate symbol, standing for a
 relation.<BR>
<BR>
<DT><B>deffunction</B><DD> Introduces a new function symbol, standing for a
 function.<BR>
<BR>
<DT><B>deflogical</B><DD> Introduces a new propositional symbol, standing for a
 truth-value.
</DL>
<!--TOC subsection Description of <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>-->

<H3><A NAME="htoc71">8.2</A>&nbsp;&nbsp;Description of <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT></H3><!--SEC END -->

The domain of discourse for the <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  consists of individuals,
relations, functions, and assertions. Unary relations are identified with
classes. We consider each of these, beginning with classes, which are given
special treatment in <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  because they are tied to <FONT COLOR=navy>SNARK</FONT>'s sort
mechanism.<BR>
<BR>
To enable the <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  interface, we place the following statement
at the top of our source files:
<PRE>
  (in-language :hpkb-with-ansi-kif)
</PRE>or
<PRE>
  (in-language :hpkb-with-kif-3.0)
</PRE>All the examples in this section will work with either version of the <FONT COLOR=navy>KIF</FONT>
interface.<BR>
<BR>
<!--TOC subsubsection Declaring Classes-->

<H4><A NAME="htoc72">8.2.1</A>&nbsp;&nbsp;Declaring Classes</H4><!--SEC END -->

<A NAME="subsec-kif-class"></A>
A class in <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  corresponds to a set, and a unary predicate
symbol (i.  e., a predicate symbol of arity 1). It is declared
with the construct <CODE>defrelation</CODE>.<BR>
<BR>
For instance, to declare a class,
<CODE>person</CODE>, we execute
<PRE>
  (defrelation person
    (class person))
</PRE>The relation name <CODE>class</CODE> is a standard name derived from the <FONT COLOR=navy>OKBC</FONT>
knowledge model.<BR>
<BR>
The declaration constructs each allow an optional string as their first
argument, which can be used for documentation:
<PRE>
  (defrelation object
      "Collection of all objects."
    (class object))
</PRE>Specifying documentation string as an optional first argument is
allowed in the <FONT COLOR=navy>ANSI</FONT> version of <FONT COLOR=navy>KIF</FONT>, but not in <FONT COLOR=navy>KIF</FONT>  3.0.<BR>
<BR>
Within the <CODE>defrelation</CODE> construct we can provide many declarations and
axioms related to the class being declared. For instance, we can declare that
one class is a subclass of another:
<PRE>
  (defrelation man
      "Collection of all men."
    (class man)
    (subclass-of man person))
</PRE>This construct introduces a new class <CODE>man</CODE> and declares that
<TT>man</TT> is a subclass of <TT>person</TT>, i.  e., that every man is
also a person. The relation name <CODE>subclass-of</CODE> is a standard
relation name based on the <FONT COLOR=navy>OKBC</FONT>  knowledge model.<BR>
<BR>
It is a convention (which <FONT COLOR=navy>SNARK</FONT>  does not enforce) that the
statements included in a declaration be relevant to the entity being
declared; in particular, it is recommended that a subclass declaration
<CODE>(subclass-of man ...)</CODE> should appear in the declaration for the class
<CODE>man</CODE>, rather
than elsewhere.<BR>
<BR>
<!--TOC subsubsection Declaring Individuals-->

<H4><A NAME="htoc73">8.2.2</A>&nbsp;&nbsp;Declaring Individuals</H4><!--SEC END -->

<A NAME="subsec-kif-individuals"></A>
If we want to introduce an individual that is not itself a set, we use the
construct <CODE>defobject</CODE>. For instance,
<PRE>
  (defobject george
    (instance-of george man))
</PRE>introduces a constant <CODE>george</CODE> that is of sort <CODE>man</CODE> and an
element of the set <CODE>man</CODE>. Here <CODE>instance-of</CODE> corresponds to
the set membership relation, and is a standard relation name derived
from the <FONT COLOR=navy>OKBC</FONT>  knowledge model.<BR>
<BR>
The predicate symbols <CODE>subclass-of</CODE> and <CODE>instance-of</CODE> are given
special treatment in <FONT COLOR=navy>SNARK</FONT>. In particular, when the class <CODE>person</CODE>
is declared, an assertion
<PRE>
  (instance-of ?person person)
</PRE>is automatically introduced; in other words, any term of sort <CODE>person</CODE>
stands for an element of the set <CODE>person</CODE>. Also, any formula of form
<PRE>
  (person &lt;term&gt;)
</PRE>where <CODE>&lt;term&gt;</CODE> is a term, is automatically rewritten as
<PRE>
  (instance-of &lt;term&gt; person).
</PRE>Thus, any use of <CODE>person</CODE> as a predicate symbol is automatically
translated into a use of <CODE>person</CODE> as a set.<BR>
<BR>
Special procedures are built into <FONT COLOR=navy>SNARK</FONT>  to take into account the
class, subclass, and object declarations during a proof. For instance,
with the above declarations, that <CODE>george</CODE> is a <CODE>man</CODE> and that
<CODE>man</CODE> is a subclass of <CODE>person</CODE>, <FONT COLOR=navy>SNARK</FONT>  will be able to prove
immediately that <CODE>george</CODE> is a person, i.  e., that
<PRE>
 (person george)
</PRE>This is rewritten as
<PRE>
 (instance-of george person)
</PRE>
The proof is carried out simply by examining the declared sorts and objects,
without invoking any axioms. Because <CODE>man</CODE> is a subset of
<CODE>person</CODE>, any member of <CODE>man</CODE> is also a member of <CODE>person</CODE>.<BR>
<BR>
It is possible to use the relation <CODE>instance-of</CODE> to assert that a class,
rather than an individual, is a member of another class. For instance, here
is a declaration of the class <CODE>woman</CODE>.
<PRE>
  (defrelation woman
      "Collection of all women."
    (class woman)
    (instance-of woman biological-classification-type))
</PRE>The statement
<PRE>
  (instance-of woman biological-classification-type)
</PRE>says that the class of women is a biological classification type, a kind of
class. This is quite different from saying that the class of women is a
subclass of the biological classification type---that would imply that every
woman is herself a class.<BR>
<BR>
It is natural to make assertions about the properties of a class
as follows.
<PRE>
  (defrelation person
    (class person)
    (average-age person 70))
</PRE>The <CODE>average-age</CODE> statement says something about the entire class of
people, not about individual members of the class. If we really want to say
something about each element of the class, we can use the construct <TT>template-slot-value</TT>, another standard relation name from the <FONT COLOR=navy>OKBC</FONT>
knowledge model:
<PRE>
  (defrelation person
    (class person)
    (template-slot-value ancestor person adam))
</PRE>Here
<PRE>
  (template-slot-value ancestor person adam)
</PRE>says that an ancestor of every person is Adam. This
is equivalent to the following <FONT COLOR=navy>SNARK</FONT>  assertion:
<PRE>
  (ancestor ?person adam)
</PRE>
<!--TOC subsubsection Declaring Relations-->

<H4><A NAME="htoc74">8.2.3</A>&nbsp;&nbsp;Declaring Relations</H4><!--SEC END -->

<A NAME="subsec-kif-relations"></A>
We have seen that when we declare a class we are simultaneously declaring a
unary predicate symbol, which stands for a unary relation. Let us consider
the declaration of n-ary relations.<BR>
<BR>
For example, suppose we want to declare a relation <CODE>possesses</CODE>, which
takes two arguments, a <CODE>person</CODE> and an <CODE>object</CODE>. Then we may say
<PRE>
  (defrelation possesses
      "a ?person possesses an ?object if he or she owns it."
    (relation-arity possesses 2)
    (nth-domain possesses 1 person)
    (nth-domain possesses 2 object))
</PRE>
An alternative, and equivalent, way to make the same declaration would
be
<PRE>
  (defrelation possesses
      "a ?person possesses an ?object if he or she owns it."
    (relation-arity possesses 2)
    (domain possesses person)
    (slot-value-type possesses  object))
</PRE>
This last formulation is acceptable only for binary relations, of
arity 2. The relation names <CODE>domain</CODE>, and <CODE>slot-value-type</CODE>
are derived from the <FONT COLOR=navy>OKBC</FONT>  knowledge model.<BR>
<BR>
The assertions involving the relations can be included in a
<CODE>defobject</CODE> construct.
<PRE>
  (defobject the-maltese-falcon
      "the-maltese-falcon is an object possessed by George."
    (instance-of the-maltese-falcon object)
    (possesses george the-maltese-falcon))
</PRE>
<A NAME="subsubsec-subclasses"></A>
There are many relations, for example, <CODE>average-age</CODE>, that apply
to classes. The arguments of such relations are constant symbols that
represent classes. While declaring such relations, the relevant
arguments should be restricted to be classes. This can be accomplished
as follows.
<PRE>
  (defrelation average-age
      "Average age of the members of a collection of objects''
    (relation-arity average-age 2)
    (nth-domain-subclass-of average-age 1 physical-object)
    (nth-domain average-age 2 integer))
</PRE>
The relation name <CODE>nth-domain-subclass-of</CODE> restricts the first argument
to only those constant symbols that represent classes that are subclasses of
<CODE>physical-object</CODE>. The relation names <TT>range</TT>-<TT>subclass</TT>-<TT>of</TT>, <TT>slot</TT>-<TT>value</TT>-<TT>type</TT>-<TT>subclass</TT>-<TT>of</TT> and <TT>domain</TT>-<TT>subclass</TT>-<TT>of</TT> may also be used.<BR>
<BR>
To support the implementation of the type restriction when the
arguments of a relation are restricted to the constant symbols
representing classes, for every <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  class, we automatically
declare a class of subclasses of that class. For example, because we
have declared a class <CODE>person</CODE>, we declare
<CODE>subclass-of-person</CODE> as a class as well. Every <CODE>subclass-of</CODE>
<CODE>person</CODE> will be an <CODE>instance-of</CODE> <CODE>subclass-of-person</CODE>.
Internally, <FONT COLOR=navy>SNARK</FONT>  reduces the <CODE>nth-domain-subclass-of</CODE>
restriction to an <CODE>nth-domain</CODE> restriction on class of
subclasses. For example,
<PRE>
    (nth-domain-subclass-of average-age 1 physical-object)
</PRE>is internally represented as
<PRE>
    (nth-domain average-age 1 subclass-of-physical-object)
</PRE>
The objective of declaring the class of all subclasses was to take
advantage of the sort system in <FONT COLOR=navy>SNARK</FONT>  to deal with meta-classes.
The sort names such as <CODE>subclass-of-person</CODE> are not meant
to be visible to the user, and are outside the scope of <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>.
It is, however, possible to use them while writing axioms. For example,
<FONT COLOR=navy>SNARK</FONT>  will recognize <CODE>?subclass-of-person</CODE> as a variable of sort
<CODE>subclass-of-person</CODE>. Quantification over classes is not a well
explored area for <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  and is open for future research.<BR>
<BR>
Any of the keyword arguments accepted by the <FONT COLOR=navy>SNARK</FONT>  relation
declarations can be supplied through <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>. For example,
the following <FONT COLOR=navy>SNARK</FONT>  declaration
<PRE>
  (declare-function-symbol 'mother 1
                           :rewrite-code 'mother-rewriter)
 </PRE>can be written in <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  as follows:
<PRE>
  (deffunction mother
        (function-arity mother 1)
        (rewrite-code mother mother-rewriter))
 </PRE>The <FONT COLOR=navy>SNARK</FONT>  keyword arguments are recognized as <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  relation
names.<BR>
<BR>
<!--TOC subsubsection Declaring Functions-->

<H4><A NAME="htoc75">8.2.4</A>&nbsp;&nbsp;Declaring Functions</H4><!--SEC END -->

<A NAME="subsec-kif-functions"></A>
<FONT COLOR=navy>KIF</FONT>  function declarations are similar to the relation declarations. For
 example, suppose we want to declare the function <CODE>mother</CODE>, which
 takes a <CODE>person</CODE> as its argument and yields a <CODE>woman</CODE> as its
 value. Then we may use the <FONT COLOR=navy>KIF</FONT>  construct
 <CODE>deffunction</CODE>, which is analogous to <CODE>defrelation</CODE>:
<PRE>
  (deffunction mother
      "the mother of a person."
    (function-arity mother 1)
    (nth-domain mother 1 person)
    (range mother woman)
    (parent (mother ?person) ?person))
</PRE>
<!--TOC subsubsection Declaring Assertions-->

<H4><A NAME="htoc76">8.2.5</A>&nbsp;&nbsp;Declaring Assertions</H4><!--SEC END -->

<A NAME="subsec-kif-assertions"></A>
The assertion declaration is an extension to <FONT COLOR=navy>KIF</FONT>, included to allow one to
make <FONT COLOR=navy>SNARK</FONT>  assertions with <FONT COLOR=navy>KIF</FONT>  syntax, outside of declarations.
Assertions may be given a name and a documentation string. For example, to
say that everyone has at most one spouse (at a given time), we can make the
assertion

<PRE>
  (assertion
   (forall ((?x1 person)
            (?x2 person)
            (?x person))
           (=&gt;
            (and (spouse ?x ?x1)
                 (spouse ?x ?x2))
            (= ?x1 ?x2)))
</PRE>
<PRE>
   :name uniqueness-of-spouse
   :documentation
    "A person may have only one spouse at a time.")
</PRE>Note that <FONT COLOR=navy>SNARK</FONT>  accepts <FONT COLOR=navy>KIF</FONT>  syntax for logical symbols, such as
 <CODE>=&gt;</CODE> instead of
 <CODE>implies</CODE>. Also note that <FONT COLOR=navy>KIF</FONT>  does not have the convention
 that <CODE>?person1</CODE> is a variable of sort <CODE>person</CODE>, say.
 Therefore we have spelled out explicitly the sort of each variable:
<PRE>
  (forall ((?x1 person)
           (?x2 person)
           (?x person)) ... )
</PRE>
<FONT COLOR=navy>SNARK</FONT>  allows automatic coercion of variable types. For example,
if the above assertion were written as
<PRE>
  (assertion
    (=&gt;
     (and (spouse ?x ?x1)
          (spouse ?x ?x2))
     (= ?x1 ?x2))
   :name uniqueness-of-spouse
   :documentation
    "A person may have only one spouse at a time.")
</PRE>and the arguments of <CODE>spouse</CODE> were declared to be of type
<CODE>person</CODE>,
 <FONT COLOR=navy>SNARK</FONT> could automatically coerce <TT>?x</TT>, <TT>?x1</TT>, and <TT>?x2</TT> to be
of types <CODE>person</CODE>. To enable such automatic sort coercion, one select
the option <TT>use</TT>-<TT>well</TT>-<TT>sorting</TT>.<BR>
<BR>
The <TT>uniqueness-of-spouse</TT> axiom can also be written as
<PRE>
  (assertion
    (=&gt;
     (and (person ?x)
          (person ?x1)
          (person ?x2)
          (spouse ?x ?x1)
          (spouse ?x ?x2))
     (equal ?x1 ?x2))
   :name uniqueness-of-spouse
   :documentation
    "A person may have only one spouse at a time.")
</PRE>
<!--TOC paragraph Exercise: Uniqueness of Mothers-in-law.-->

<H5>Exercise: Uniqueness of Mothers-in-law.</H5><!--SEC END -->

<A NAME="exec-mother-in-law"></A>
Within the <FONT COLOR=navy>KIF</FONT>  extension of <FONT COLOR=navy>SNARK</FONT>  introduce a relation
<CODE>mother-in-law</CODE>. Using your definition and the <FONT COLOR=navy>KIF</FONT>  family theory
introduced in this section, use <FONT COLOR=navy>SNARK</FONT>  to prove that everyone has at most
one mother-in-law.<BR>
<BR>
<!--TOC subparagraph Solution.-->

<H5>Solution.</H5><!--SEC END -->
 The definition of a mother-in-law is given within
the <FONT COLOR=navy>KIF</FONT>  declaration
<PRE>
  (defrelation mother-in-law
      "?x1 is the mother-in-law of ?x2
       if ?x1 is the mother of the spouse of ?x2."
    (relation-arity mother-in-law 2)
    (domains mother-in-law person person)
    (forall ((?x1 person)
             (?x2 person)
             (?x person))
      (&lt;=&gt;
       (mother-in-law ?x1 ?x2)
       (exists ((?x person))
               (and
                (spouse ?x1 ?x)
                (equal ?x2 (mother ?x)))))))
</PRE>
To prove the uniqueness of the mother-in-law, we give <FONT COLOR=navy>SNARK</FONT>  the task

<PRE>
  (prove '(forall ((?x1 person)
                   (?x2 person)
                   (?x person))
           (=&gt;
            (and
             (mother-in-law ?x ?x1)
             (mother-in-law ?x ?x2))
            (equal ?x1 ?x2))))
</PRE>
<!--TOC subsection Relationship of <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  with <FONT COLOR=navy>SNARK</FONT>-->

<H3><A NAME="htoc79">8.3</A>&nbsp;&nbsp;Relationship of <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>  with <FONT COLOR=navy>SNARK</FONT></H3><!--SEC END -->

It is helpful to consider the equivalence between the <FONT COLOR=navy>KIF</FONT>+<FONT COLOR=navy>C</FONT>
constructs and the native <FONT COLOR=navy>SNARK</FONT>  constructs.<BR>
<BR>
In both <FONT COLOR=navy>SNARK</FONT>  and <FONT COLOR=navy>KIF</FONT>&nbsp; the same function and relation symbol may
occur with different arities. However, in <FONT COLOR=navy>SNARK</FONT>  there is no
assumption that the meaning of a symbol with arity 2, say, has any
relation at all to the meaning of the same symbol with arity 3. In
<FONT COLOR=navy>KIF</FONT>, on the other hand, the assumption is that if the same symbol
occurs with varying arity, all those occurrences stand for the same
function, and the function itself has variable arity.<BR>
<BR>
For example, in <FONT COLOR=navy>SNARK</FONT>  we could introduce a unary function <CODE>minus</CODE> and
a binary function <CODE>minus</CODE>, without the idea that both of these are
instances of the same function. In <FONT COLOR=navy>KIF</FONT>, we would need to represent these
functions by different symbols. If we talk about <CODE>plus</CODE> with two
arguments in one place and three arguments in another in <FONT COLOR=navy>KIF</FONT>, it is
understood that these are the same function.<BR>
<BR>
<FONT COLOR=navy>KIF</FONT>  has two directions of implication connective, <CODE>=&gt;</CODE> and <CODE>&lt;=</CODE>,
analogous to the <FONT COLOR=navy>SNARK</FONT> <CODE>implies</CODE> and <CODE>implied-by</CODE>. However,
while the <FONT COLOR=navy>SNARK</FONT>  connectives accept exactly two arguments, the <FONT COLOR=navy>KIF</FONT>
connectives accept two or more. The <FONT COLOR=navy>KIF</FONT>
<PRE>
  (=&gt; &lt;Form1&gt; ... &lt;Formn&gt; &lt;Form&gt;)
</PRE>is equivalent to the <FONT COLOR=navy>SNARK</FONT>
<PRE>
  (implies (and &lt;Form1&gt; ... &lt;Formn&gt;) &lt;Form&gt;)
</PRE>and the <FONT COLOR=navy>KIF</FONT>
<PRE>
  (&lt;= &lt;Form&gt; &lt;Form1&gt; ... &lt;Formn&gt;)
</PRE>is equivalent to the <FONT COLOR=navy>SNARK</FONT>
<PRE>
  (implied-by &lt;Form&gt; (and &lt;Form1&gt; ... &lt;Formn&gt;))
</PRE>
The declaration
<PRE>
  (defrelation person
    (class person))
</PRE>makes the following declarations in <FONT COLOR=navy>SNARK</FONT><UL><LI>
 the sort <TT>person</TT>.<BR>
<BR>
<LI>a constant <TT>person</TT>, which stands
 for the set of all people.<BR>
<BR>
<LI>a unary predicate symbol <CODE>person</CODE>, which stands for the relation
 that is true for people and false for other entities.
</UL>
Thus the <FONT COLOR=navy>KIF</FONT>  <CODE>class</CODE> declaration has more effects than the simple
 <FONT COLOR=navy>SNARK</FONT>  declaration
<PRE>
   (declare-sort 'person)
</PRE>
The following declaration
<PRE>
  (defrelation possesses
      "a ?person possesses an ?object if he or she owns it."
    (relation-arity possesses 2)
    (nth-domain possesses 1 person)
    (nth-domain possesses 2 object)
</PRE>is equivalent to the <FONT COLOR=navy>SNARK</FONT>  declaration
<PRE>
  (declare-predicate-symbol 'possesses 2
    :sort '(boolean person object))
</PRE>
<!--TOC subsection Built-in Number Sorts-->

<H3><A NAME="htoc80">8.4</A>&nbsp;&nbsp;Built-in Number Sorts</H3><!--SEC END -->

<A NAME="sec:numbers"></A>
<FONT COLOR=navy>SNARK</FONT>  has some built-in sorts of numbers.
The number sorts in <FONT COLOR=navy>SNARK</FONT>  are based on the <FONT COLOR=navy>ANSI  KIF</FONT>
specification. <FONT COLOR=navy>SNARK</FONT>  recognizes the following number sorts: <TT>number</TT>,
<TT>complex</TT>, <TT>real</TT>, <TT>rational</TT>, <TT>integer</TT>, <TT>natural</TT>, <TT>zero</TT>, <TT>positive</TT>, <TT>negative</TT>,
<TT>odd</TT>, and <TT>even</TT>. The sort <TT>number</TT>  is declared to be a subsort of <TT>complex</TT>,
<TT>real</TT>  a subsort of <TT>complex</TT>, <TT>rational</TT>  a subsort of <TT>real</TT>,
and <TT>integer</TT>  a subsort of <TT>rational</TT>. The sort <TT>real</TT>  is partitioned
into three disjoint subsorts: <TT>negative</TT>, <TT>zero</TT>, and <TT>positive</TT>.
The sort <TT>integer</TT>is partitioned into <TT>even</TT>  and <TT>odd</TT>, with <TT>zero</TT>  included
as a subsort of <TT>even</TT>. The sort <TT>natural</TT>  comprises the
nonnegative integers. To enable the automatic declaration of these
number sorts, one must select the option <TT>use</TT>-<TT>number</TT>-<TT>sorts</TT>.<BR>
<BR>
<FONT COLOR=navy>SNARK</FONT>'s number sorts are based on those of <FONT COLOR=navy>KIF</FONT>, which are based in turn
on <FONT COLOR=navy>COMMON LISP</FONT>'s number types.<BR>
<BR>
<!--TOC section Acknowledgments-->

<H2>Acknowledgments</H2><!--SEC END -->

We are grateful for comments from Nikolaj Bjorner and Jose Meseguer.<BR>
<BR>
The research reported here has been partly supported by DARPA under Contracts
N66001-97-C-8550 (HPKB) and N66001-97-8551-00-SC-01, Subcontract
PSRW-97-8551-00-SC-01 (Genoa).
<A NAME="bibliography"></A>
<!--TOC section References-->

<H2>References</H2><!--SEC END -->
<DL COMPACT=compact><DT><FONT COLOR=purple><A NAME="allen">[Allen]</A></FONT><DD> J. F. Allen, Time and Time Again: The Many Ways
 to Represent Time, <EM>International Journal of Intelligent Systems</EM>,
 Vol. 6, No. 4 (July 1991), pp. 341--355.<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="burckert">[Burckert]</A></FONT><DD> H.-J. Brckert, <EM>A Resolution Principle for a Logic with Restricted Quantifiers</EM>,
Lecture Notes in Artificial Intelligence No. 568, Springer Verlag,
Berlin (1991).<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="chang">[Chang]</A></FONT><DD> C. L. Chang and R. C. T. Lee, <EM>Symbolic Logic and Mechanical Theorem Proving</EM>, Academic Press, New
 York, NY (1973).<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="okbc">[Chaudhri]</A></FONT><DD> V. K. Chaudhri, A. Farquhar, et al., <FONT COLOR=navy>Okbc</FONT>: A Programmatic Foundation for Knowledge Base Interoperability,
 <EM>Proceedings of the AAAI-98</EM>, Madison, WI (1998).<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="recursive-path">[Dershowitz]</A></FONT><DD> N. Dershowitz and
J.-P. Jouannaud, ``Rewrite Systems,'' in J. van Leeuwen (editor), <EM>Handbook
of Theoretic Computer Science</EM>, Elsevier, Amsterdam, The Netherlands
(1989), pp. 241--320.<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="kif">[Genesereth]</A></FONT><DD> M.  R.  Genesereth and R.  E.  Fikes, <EM>Knowledge
Interchange Format, Version 3.0 Reference Manual</EM>, (Logic-92-1) (1992).<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="ansi-commonlisp">[Graham]</A></FONT><DD> P.  Graham, <EM><FONT COLOR=navy>ANSI</FONT>  Common Lisp</EM>,
 Prentice Hall, Englewood Cliffs, NJ (1996).<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="cyc">[Lenat]</A></FONT><DD> D.  Lenat and R.  V.  Guha, <EM>Building Large
 Knowledge Based Systems</EM>, Addison-Wesley, Reading, MA (1990). See also
http://www.cyc.com.<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="cyc-ul">[Cyc-UL]</A></FONT><DD> D.  Lenat, <EM>Cyc Upper Ontology</EM>,
 See http://www.cyc.com/cyc-2-1/index.html<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="otter">[McCune]</A></FONT><DD> W.  McCune, <EM>Otter 3.0 User's Guide</EM>,
 Technical Report ANL-94/6, Argonne National Laboratory, Argonne, IL
 (1994).<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="manna">[Manna]</A></FONT><DD> Z.  Manna and R.  Waldinger, <EM>Deductive Foundations of Computer Programming</EM>, Addison-Wesley,
 Reading, MA (1993).<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="waldinger">[Waldinger]</A></FONT><DD> Z.  Manna and R.  Waldinger,
 ``Fundamentals of Deductive Program Synthesis,'' <EM>IEEE
 Transactions on Software Engineering,</EM> Vol. 18, No. 8 (August 1992),
 pp.  674--704.<BR>
<BR>
<DT><FONT COLOR=purple><A NAME="commonlisp-hyperspec">[Pitman]</A></FONT><DD> K.  Pitman, <EM>Common Lisp
 HyperSpec</EM>, Harlequin Group, Cambridge, UK (1996).</DL>
<!--BEGIN NOTES document-->
<HR WIDTH="50%" SIZE=1><DL><DT><FONT SIZE=5><A NAME="note1" HREF="#text1">1</A></FONT><DD>Unless <FONT COLOR=navy>SNARK</FONT>  option
<TT>allow-keyword-proposition-symbols</TT>,
<TT>allow-keyword-predicate-symbols</TT>, or
<TT>allow-keyword-function-symbols</TT> is true.
<DT><FONT SIZE=5><A NAME="note2" HREF="#text2">2</A></FONT><DD>Unless <FONT COLOR=navy>SNARK</FONT>  option
<TT>allow-keyword-constant-symbols</TT> is true.
<DT><FONT SIZE=5><A NAME="note3" HREF="#text3">3</A></FONT><DD>Unless <FONT COLOR=navy>SNARK</FONT>  option
<TT>allow-keyword-sort-symbols</TT> is true.
<DT><FONT SIZE=5><A NAME="note4" HREF="#text4">4</A></FONT><DD>This is a reformulation of a blocks-world problem
of Robert C. Moore.
</DL>
<!--END NOTES-->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2>
<BLOCKQUOTE><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
<A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A>.
</EM></BLOCKQUOTE>
</BODY>
</HTML>
