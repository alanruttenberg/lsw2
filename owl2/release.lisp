;; Load an ontology, merge all axioms into one ontology. (done)
;; Run reasoner. Add inferred subclass axioms.  (done)
:; Do a little materialization.  (todo)
;; Copy the ontology annotations from the top ontology (not the imports)  (done)
;; Don't add certain duplicates, such as extra copies of definitions or annotation. Be aware of duplicate
;; axioms that might be pulled in by chains of imports and prefer the proximate one. (todo)
;; Add imported-from annotations to the imported ontologies (done)
;; Add a note saying how this was created (done)

(defun new-empty-kb (ontology-iri &key reasoner)
  (let* ((manager (#"createOWLOntologyManager" 'org.semanticweb.owlapi.apibinding.OWLManager))
	 (ont (#"createOntology" manager (to-iri (uri-full ontology-iri)))))
    (make-v3kb :name ontology-iri :manager manager :ont ont :datafactory (#"getOWLDataFactory" manager) :default-reasoner reasoner)))
  
(defun make-merged-candidate (source namespace &key (reasoner :factpp) release-base)
  (unless release-base
    (setq release-base (merge-pathnames (make-pathname :directory (append (remove "ontology" (remove "src" (pathname-directory source) :test 'equal) :test 'equal) '("releases")))))
    (if (probe-file release-base)
	(format *debug-io* "Using release directory: ~a~%" release-base)
	(error "Can't figure out release base (guessed ~a). Pass it to the function" release-base)))
  (setq namespace (string-downcase namespace))
  (when (not (v3kb-p source))
    (setq source (load-ontology source))
    (let ((destont (new-empty-kb (make-uri (format nil "http://purl.obolibrary.org/obo/~a.owl" namespace))))
	  (inferred-axiom-ont (new-empty-kb (make-uri (format nil "http://purl.obolibrary.org/obo/~a-inferred.owl" namespace)))))
      (check-ontology source :classify t :reasoner reasoner)
      (loop for annotation in (jss::j2list (#"getAnnotations" (v3kb-ont source)))
	    for prop = (make-uri (#"toString" (#"getIRI" (#"getProperty"  annotation))))
	    unless (eq prop !owl:versionIRI)
		   do (add-ontology-annotation  annotation destont))
      (dolist (an (make-imported-from-merged-annotations source namespace))
	(add-ontology-annotation an destont))
      (add-version-iri destont (make-versioniri namespace))
      (add-ontology-annotation `(,!rdfs:comment "This version of the ontology is the merge of all its imports and has added axioms inferred by an OWL reasoner") destont)
      (loop for (nil nil ont) in (loaded-documents source)
	    do
	       (each-axiom ont
		   (lambda(ax)
		     (add-axiom ax destont))
		 nil))
      (ontology-with-inferred-axioms source :to-ont inferred-axiom-ont)
      (let ((dest (merge-pathnames (format nil "~a-merged.owl" namespace) (ensure-release-dir release-base))))
	(to-owl-syntax destont :rdfxml (merge-pathnames (format nil "~a.owl" namespace) (ensure-release-dir release-base)))
	(values destont dest)))))

(defun make-imported-from-merged-annotations (source namespace)
  (let ((date (ontology-version-date))
	(imported-from !<http://purl.obolibrary.org/obo/IAO_0000412>))
    (loop for ont in (jss::j2list (#"getImports" (v3kb-ont source)))
	  for id = (#"getOntologyID" ont)
	  for ontologyiri = (#"toString" (#"get" (#"getOntologyIRI" id)))
	  collect 
	  (if (equal (third (pathname-directory ontologyiri)) namespace)
	      (let ((versioned (namestring (merge-pathnames (make-pathname :directory `(:relative ,date)) ontologyiri))))
		(list imported-from (make-uri versioned)))
	      (if (equal (pathname-name ontologyiri) namespace)
		  (let ((versioned (namestring (merge-pathnames (make-pathname :directory `(:relative ,namespace ,date)) ontologyiri))))
		    (list imported-from (make-uri versioned)))
		  (list imported-from (make-uri ontologyiri)))))))

(defun ontology-version-date (&optional (when (get-universal-time)))
  (multiple-value-bind (second minute hour date month year day)  (decode-universal-time when)
    (declare (ignore second minute hour  day))
    (format nil "~a-~2,'0D-~2,'0D" year month date)))

(defun make-versioniri (namespace)
  (make-uri (format nil "http://purl.obolibrary.org/obo/~a/~a/~a.owl" namespace (ontology-version-date) namespace)))

(defun ensure-release-dir (release-base) 
  (let ((basename (namestring (translate-logical-pathname release-base))))
    (when (not (#"matches" basename ".*/$"))
      (setq basename (concatenate 'string basename "/")))
    (declare (ignore second minute hour  day))
    (ensure-directories-exist 
     (merge-pathnames (make-pathname :directory `(:relative ,(ontology-version-date)))
		      basename))))
