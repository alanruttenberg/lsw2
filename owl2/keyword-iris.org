# -*- Mode: POLY-ORG;  -*- ---
#+PROPERTY: literate-lang lisp
#+PROPERTY: literate-load yes
#+OPTIONS: html-postamble:nil
#+OPTIONS: ^:nil

#+Author: Alan Ruttenberg
#+Title: Keyword-IRIs

#+begin_src lisp
(in-package :cl-user)
#+end_src

* Keyword IRIs

This class is intended as a mixin, and provides a facility to name IRIs
by keywords, transform triples using them by replacing the the keywords
with the IRIs and collecting prefixes needed for a SPARQL query.

If the SPARQL functions are used then the class mixing this in should have
a slot repo. The value can either be a string, in which 

The slots are:

- iri-counter :: Allocation of IRIs is via a UUID followed by an incrementing counter.
  This stores the counter. 
- iri-prefix :: Prefix of allocated IRIs, e.g. "demo:"
- iri-abbreviations :: We use keywords for IRIs, to make them easier to
  work with. Call register-term-nickname to add a translation from a
  keyword to the set. Call define-abbreviations for the initial set, which
  can be later added to.
- label-source :: When defining the keywords, if there's a label source
  you can give the label instead of the IRI and it will look up the IRI.
- repo :: If SPARQL queries are to be done either a string, in which
  case an endpoint query is done, a kb in which the usual sparql method
  is called or a graphdb repository, which which case the sparql-query
  method on it is called. repo can also just be a method rather than a slot.

The main methods are
- fresh-instance-iri: returns an IRI that hasn't been used yet
- register-term-nickname: associates a keyword with an IRI
- sparql-query: Runs a query against repo. Query may use nicknames. 
- sparql-string: Renders a (lispy) sparql query to a proper SPARQL string.
  
#+begin_src lisp

(defparameter *iri-counter* 0)
  
(defclass keyword-iris ()
  ((iri-prefix :accessor iri-prefix :initarg :iri-prefix :initform nil)
   (iri-abbreviations :accessor iri-abbreviations :initform nil)
   (label-source :accessor label-source :initarg :label-source :allocation :class)
   (allow-unknown-namespaces :initarg :allow-unknown-namespaces :initform nil :accessor allow-unknown-namespaces)
   ))

#+end_src

** Allocate IRIs

Assume the prefix is unique so we only need a counter in addition to create a fresh IRI

~reset-iri-counter~ resets the counter back to 0. Useful if you are
doing a number of repeats of triple generation and you don't want the
counter to keep growing.

#+begin_src lisp 
(defmethod reset-iri-counter ((kwiri keyword-iris))
  (setq *iri-counter* 0))
#+end_src

~fresh-instance-iri~ allocates a new IRI 

#+begin_src lisp
(defmethod fresh-instance-iri ((kwiri keyword-iris))
  (threads:synchronized-on
   kwiri
   (let ((*allow-unknown-namespaces* (allow-unknown-namespaces kwiri)))
     (incf *iri-counter*)
     (make-uri-base-relative (format nil "~x" *iri-counter*) (iri-prefix kwiri)))))
#+end_src

** Let us use keywords for IRIs

Register a new keyword. Lookup labels from label source we create. Kind is optional,
mostly to jog memory. Use :property, :individual, :class 
   
#+begin_src lisp
(defparameter *sparql-reserved-keywords* '(:filter :optional :union :with :bind :as :graph :minus :exists :not-exists))

(defmethod register-term-nickname ((kwiri keyword-iris) keyword iri-or-label kind)
  (when (member keyword *sparql-reserved-keywords*)
    (warn "IRI keyword ~s is reserved for SPARQL. You won't be able to use it in a SPARQL query"))
  (let ((iri (if (stringp iri-or-label)
                 (make-uri-from-label-source (label-source kwiri) iri-or-label)
                 (if (consp iri-or-label)
                     (eval iri-or-label)
                     iri-or-label))))
    (pushnew (list keyword IRI kind) (iri-abbreviations kwiri) :key 'car)
    iri))
#+end_src

Given keyword, return IRI

#+begin_src lisp 
(defmethod abbreviation-iri ((kwiri keyword-iris) what)
  (second (assoc what (iri-abbreviations kwiri))))

#+end_src

** Translate the keyword abbreviations in a form to IRIs

Takes any form  - assertions, triples, or body of a sparql query and replaces the keywords
that define IRIs with the IRIs.

#+begin_src lisp
(defmethod replace-iri-abbreviations ((kwiri keyword-iris) axioms)
  (eval-uri-reader-macro (tree-replace (lambda(el) (if (keywordp el) (or (abbreviation-iri kwiri el) el) el)) axioms)))
#+end_src

** Define sparql-query that uses our abbreviations as prefixes

The SPARQL query will use prefixes based on the labels in the body, in order to make the
query easier to read.

Write a string with prefix definitions. If which is supplied only those prefixes in which.   

#+begin_src lisp
(defmethod prefixes-for-abbreviations ((kwiri keyword-iris) &optional which)
  (with-output-to-string (s)
    (loop for (ab  class) in (iri-abbreviations kwiri)
          when (or (null which) (member ab which))
            do (format s "PREFIX ~a: <~a>~%" (substitute #\_ #\- (string-downcase (string ab)))
                       (uri-full (eval-uri-reader-macro class))))))
#+end_src

Figure out which prefixes we are using in a query

#+begin_src lisp
(defmethod get-used-prefixes ((kwiri keyword-iris) query &aux them)
  (let ((*allow-unknown-namespaces* t))
    (tree-walk (eval-uri-reader-macro query)
             (lambda(e)
               (when (uri-p e)
                 (when (#"matches" (uri-abbreviated e) ".*:$")
                   (pushnew (intern (substitute #\- #\_ (string-upcase (subseq (uri-abbreviated e) 0 (- (length (uri-abbreviated e)) 1))))
                                    'keyword)  them :test 'equalp))))))
  them)
#+end_src

Helper methods that translates use of keywords in the queries into prefix uris.

#+begin_src lisp
(defmethod replace-keywords-with-prefixes ((kwiri keyword-iris) query)
  (list* (car query) (second query)
         (tree-replace (lambda(x)
                         (if (and (keywordp x)
                                  (find x (iri-abbreviations kwiri) :key 'car))
                             (let ((*allow-unknown-namespaces* t))
                               (make-uri nil (concatenate 'string (substitute #\_ #\- (string-downcase (string x))) ":")))
                             x))
                       (cddr query))))
#+end_src


** sparql-query 

sparql-query method that adds our prefixes to the query. Accepts either prefix versions of the query e.g.
!foo_bar: for or keywords directly e.g. :foo-bar

#+begin_src lisp 
(defmethod sparql-query ((kwiri keyword-iris) query &rest args &key labels-for &allow-other-keys)
  (let ((cl-user::*allow-unknown-namespaces* t))
    (setq query (replace-keywords-with-prefixes kwiri query))
    (setq query
          (concatenate 'string (prefixes-for-abbreviations kwiri (get-used-prefixes kwiri query))
                       (sparql-stringify query nil :labels-for labels-for)))
    (let ((queryfn (if (find :format args) 'sparql-endpoint-query 'sparql)))
      (cond ((stringp (repo kwiri))
             (apply queryfn (repo kwiri) query args))
            ((or (typep (repo kwiri) 'graphdb-repository) (typep (repo kwiri) 'graphdb9-repository))
             (apply queryfn (query-endpoint (repo kwiri))  query args))
            ((v3kb-p (repo kwiri))
             (apply 'sparql query args))
            (t (error "don't know how to do a sparql query against ~a" (repo kwiri)))))))
#+end_src

** sparql-string

#+begin_src lisp
(defmethod sparql-string ((kwiri keyword-iris) query &key labels-for &allow-other-keys)
  (let ((*allow-unknown-namespaces* t)
        (query (replace-keywords-with-prefixes kwiri query)))
    (concatenate 'string (prefixes-for-abbreviations kwiri (get-used-prefixes kwiri query))
                 (sparql-stringify query nil :labels-for labels-for))))
#+end_src


** Helper to generate UUIDs 

#+begin_src lisp
(defun uuid ()
  (#"toString" (#"randomUUID" 'util.uuid)))
#+end_src

