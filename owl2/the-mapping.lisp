(setq *rules* nil)

(defun add-rule (pattern action)
  (setq *rules* (append *rules* (list (cons pattern action)))))

(add-rule
 '(seq ?el)
 (lambda(bindings)
   (let ((*bindings* bindings))
     (let ((*head* (fresh-blank)))
       (triple *head* !rdf:first (t (? ?el)))
       (triple *head* !rdf:rest !rdf:nil)
       *head*))))

(add-rule
 '(seq (?+ ?el))
 (lambda(bindings)
   (let ((*bindings* bindings))
     (let ((*head* (fresh-blank)))
       (triple *head* !rdf:first (t (first (? ?el))))
       (when (rest (? ?el))
	 (triple *head* !rdf:rest (t `(seq ,@(rest (? ?el))))))
       *head*))))

;; Contents below here generated by (write-defs)


;; Not automatically translated - overridden by manual translation
(defrdfm ontology
    (:pattern
     (ontology ?ontologyiri (??a ?versionuri)
	       (?+ ?multiple-annotations/axioms))
     :case :subscript-free)
  (triple ?ontologyiri
	  !rdf:type
	  !owl:Ontology)
  (if ?versionuri
      (if (uri-p ?versionuri)
	  (triple ?ontologyiri
		  !owl:versionIRI
		  ?versionuri)
	  (push ?versionuri ?multiple-annotations/axioms)))
  (loop while (memq (car (car ?multiple-annotations/axioms))
		  '(imports import))
     do (triple ?ontologyiri
		!owl:imports
		(second (pop ?multiple-annotations/axioms))))
  (loop while (eq (car (car ?multiple-annotations/axioms))
		  'annotation)
     do
					;	      (annotation (annotation ..) p v) -> (annotation-assertion (annotation ...) p o v)
     (let ((head (butlast (first ?multiple-annotations/axioms) 2))
	   (tail (last (first ?multiple-annotations/axioms) 2)))
       (pop ?multiple-annotations/axioms)
       (t `(annotationassertion ,@(cdr head) ,(first tail) ,?ontologyiri ,(second tail)))))
  (loop while ?multiple-annotations/axioms
     do (t (pop ?multiple-annotations/axioms))))

(defrdfm ?class 
    (:pattern (?class) :head ?class :case :subscript-free)
)

(defrdfm ?datatype 
    (:pattern (?datatype) :head ?datatype :case :subscript-free)
)

(defrdfm ?object-property 
    (:pattern (?object-property) :head ?object-property :case :subscript-free)
)

(defrdfm ?data-property 
    (:pattern (?data-property) :head ?data-property :case :subscript-free)
)

(defrdfm ?annotation-property 
    (:pattern (?annotation-property) :head ?annotation-property :case :subscript-free)
)

(defrdfm ?iri 
    (:pattern (?iri) :head ?iri :case :subscript-free)
)

(defrdfm ?individual 
    (:pattern (?individual) :head ?individual :case :subscript-free)
)

(defrdfm ?literal 
    (:pattern (?literal) :head ?literal :case :subscript-free)
)

(defrdfm declaration 
    (:pattern (declaration (datatype ?datatype)) :case :subscript-free)
  (triple (t ?datatype) !rdf:type !rdfs:Datatype))

(defrdfm declaration 
    (:pattern (declaration (class ?class)) :case :subscript-free)
  (triple (t ?class) !rdf:type !owl:Class))

(defrdfm declaration 
    (:pattern (declaration (objectproperty ?object-property)) :case :subscript-free)
  (triple (t ?object-property) !rdf:type !owl:ObjectProperty))

(defrdfm declaration 
    (:pattern (declaration (dataproperty ?data-property)) :case :subscript-free)
  (triple (t ?data-property) !rdf:type !owl:DatatypeProperty))

(defrdfm declaration 
    (:pattern (declaration (annotationproperty ?annotation-property)) :case :subscript-free)
  (triple (t ?annotation-property) !rdf:type !owl:AnnotationProperty))

(defrdfm declaration 
    (:pattern (declaration (namedindividual ?named-individual)) :case :subscript-free)
  (triple (t ?named-individual) !rdf:type !owl:NamedIndividual))

(defrdfm objectinverseof 
    (:pattern (objectinverseof ?object-property) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !owl:inverseOf (t ?object-property)))

(defrdfm dataintersectionof 
    (:pattern (dataintersectionof (:subscript ?data-range 1) :elipsis (:subscript ?data-range ?n)) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !rdfs:Datatype)
  (triple (:blank ?x) !owl:intersectionOf (t (seq (:subscript ?data-range 1) :elipsis (:subscript ?data-range ?n)))))

(defrdfm dataunionof 
    (:pattern (dataunionof (:subscript ?data-range 1) :elipsis (:subscript ?data-range ?n)) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !rdfs:Datatype)
  (triple (:blank ?x) !owl:unionOf (t (seq (:subscript ?data-range 1) :elipsis (:subscript ?data-range ?n)))))

(defrdfm datacomplementof 
    (:pattern (datacomplementof ?data-range) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !rdfs:Datatype)
  (triple (:blank ?x) !owl:datatypeComplementOf (t ?data-range)))

(defrdfm dataoneof 
    (:pattern (dataoneof (:subscript ?literal 1) :elipsis (:subscript ?literal ?n)) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !rdfs:Datatype)
  (triple (:blank ?x) !owl:oneOf (t (seq (:subscript ?literal 1) :elipsis (:subscript ?literal ?n)))))

;; Not automatically translated - overridden by manual translation
(defrdfm datatyperestriction
         (:pattern
          (datatyperestriction ?datatype
           (?+ ?multiple-?facet-value-pairs))
          :head (:blank ?x) :case :subscript-free)
         (triple (:blank ?x)
                 (make-uri nil "rdf:type")
                 (make-uri nil "rdfs:Datatype"))
         (triple (:blank ?x)
                 (make-uri nil "owl:onDatatype")
                 (t ?datatype))
         (loop for (facet value) on ?multiple-?facet-value-pairs by
                   #'cddr
               with blanks
               for blank = (fresh-blank)
               do (triple blank facet value)
                  (push blank blanks)
               finally (triple (:blank ?x)
                                  (make-uri nil
                                            "owl:withRestrictions")
                                  (t (system::backq-list* 'seq
                                                         (reverse blanks))))))
(defrdfm objectintersectionof 
    (:pattern (objectintersectionof (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:Class)
  (triple (:blank ?x) !owl:intersectionOf (t (seq (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)))))

(defrdfm objectunionof 
    (:pattern (objectunionof (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:Class)
  (triple (:blank ?x) !owl:unionOf (t (seq (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)))))

(defrdfm objectcomplementof 
    (:pattern (objectcomplementof ?class-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Class)
  (triple (:blank ?x) !owl:complementOf (t ?class-expression)))

(defrdfm objectoneof 
    (:pattern (objectoneof (:subscript ?individual 1) :elipsis (:subscript ?individual ?n)) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:Class)
  (triple (:blank ?x) !owl:oneOf (t (seq (:subscript ?individual 1) :elipsis (:subscript ?individual ?n)))))

(defrdfm objectsomevaluesfrom 
    (:pattern (objectsomevaluesfrom ?object-property-expression ?class-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:someValuesFrom (t ?class-expression)))

(defrdfm objectallvaluesfrom 
    (:pattern (objectallvaluesfrom ?object-property-expression ?class-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:allValuesFrom (t ?class-expression)))

(defrdfm objecthasvalue 
    (:pattern (objecthasvalue ?object-property-expression ?individual) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:hasValue (t ?individual)))

;; Not automatically translated - overridden by manual translation
(defrdfm objecthasself 
    (:pattern (objecthasself ?object-property-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:hasSelf (make-literal "true" !xsd:boolean)))

(defrdfm objectmincardinality 
    (:pattern (objectmincardinality ?n ?object-property-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:minCardinality (make-literal ?n !xsd:nonNegativeInteger)))

(defrdfm objectmincardinality 
    (:pattern (objectmincardinality ?n ?object-property-expression ?class-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:minQualifiedCardinality (make-literal ?n !xsd:nonNegativeInteger))
  (triple (:blank ?x) !owl:onClass (t ?class-expression)))

(defrdfm objectmaxcardinality 
    (:pattern (objectmaxcardinality ?n ?object-property-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:maxCardinality (make-literal ?n !xsd:nonNegativeInteger)))

(defrdfm objectmaxcardinality 
    (:pattern (objectmaxcardinality ?n ?object-property-expression ?class-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:maxQualifiedCardinality (make-literal ?n !xsd:nonNegativeInteger))
  (triple (:blank ?x) !owl:onClass (t ?class-expression)))

(defrdfm objectexactcardinality 
    (:pattern (objectexactcardinality ?n ?object-property-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:cardinality (make-literal ?n !xsd:nonNegativeInteger)))

(defrdfm objectexactcardinality 
    (:pattern (objectexactcardinality ?n ?object-property-expression ?class-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:qualifiedCardinality (make-literal ?n !xsd:nonNegativeInteger))
  (triple (:blank ?x) !owl:onClass (t ?class-expression)))

(defrdfm datasomevaluesfrom 
    (:pattern (datasomevaluesfrom ?data-property-expression ?data-range) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:someValuesFrom (t ?data-range)))

(defrdfm datasomevaluesfrom 
    (:pattern (datasomevaluesfrom (:subscript ?data-property-expression 1) :elipsis (:subscript ?data-property-expression ?n) ?data-range) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperties (t (seq (:subscript ?data-property-expression 1) :elipsis (:subscript ?data-property-expression ?n))))
  (triple (:blank ?x) !owl:someValuesFrom (t ?data-range)))

(defrdfm dataallvaluesfrom 
    (:pattern (dataallvaluesfrom ?data-property-expression ?data-range) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:allValuesFrom (t ?data-range)))

(defrdfm dataallvaluesfrom 
    (:pattern (dataallvaluesfrom (:subscript ?data-property-expression 1) :elipsis (:subscript ?data-property-expression ?n) ?data-range) :head (:blank ?x) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperties (t (seq (:subscript ?data-property-expression 1) :elipsis (:subscript ?data-property-expression ?n))))
  (triple (:blank ?x) !owl:allValuesFrom (t ?data-range)))

(defrdfm datahasvalue 
    (:pattern (datahasvalue ?data-property-expression ?literal) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:hasValue (t ?literal)))

(defrdfm datamincardinality 
    (:pattern (datamincardinality ?n ?data-property-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:minCardinality (make-literal ?n !xsd:nonNegativeInteger)))

(defrdfm datamincardinality 
    (:pattern (datamincardinality ?n ?data-property-expression ?data-range) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:minQualifiedCardinality (make-literal ?n !xsd:nonNegativeInteger))
  (triple (:blank ?x) !owl:onDataRange (t ?data-range)))

(defrdfm datamaxcardinality 
    (:pattern (datamaxcardinality ?n ?data-property-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:maxCardinality (make-literal ?n !xsd:nonNegativeInteger)))

(defrdfm datamaxcardinality 
    (:pattern (datamaxcardinality ?n ?data-property-expression ?data-range) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:maxQualifiedCardinality (make-literal ?n !xsd:nonNegativeInteger))
  (triple (:blank ?x) !owl:onDataRange (t ?data-range)))

(defrdfm dataexactcardinality 
    (:pattern (dataexactcardinality ?n ?data-property-expression) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:cardinality (make-literal ?n !xsd:nonNegativeInteger)))

(defrdfm dataexactcardinality 
    (:pattern (dataexactcardinality ?n ?data-property-expression ?data-range) :head (:blank ?x) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:Restriction)
  (triple (:blank ?x) !owl:onProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:qualifiedCardinality (make-literal ?n !xsd:nonNegativeInteger))
  (triple (:blank ?x) !owl:onDataRange (t ?data-range)))

(defrdfm subclassof 
    (:pattern (subclassof (:subscript ?class-expression 1) (:subscript ?class-expression 2)) :case :named-variable)
  (triple (t (:subscript ?class-expression 1)) !rdfs:subClassOf (t (:subscript ?class-expression 2))))

(defrdfm equivalentclasses 
    (:pattern (equivalentclasses (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)) :case :foreach)
  (triple (t (:subscript ?class-expression 1)) !owl:equivalentClass (t (:subscript ?class-expression 2)))
  :elipsis
  (triple (t (:subscript ?class-expression ?n-1)) !owl:equivalentClass (t (:subscript ?class-expression ?n))))

(defrdfm disjointclasses 
    (:pattern (disjointclasses (:subscript ?class-expression 1) (:subscript ?class-expression 2)) :case :named-variable)
  (triple (t (:subscript ?class-expression 1)) !owl:disjointWith (t (:subscript ?class-expression 2))))

(defrdfm disjointclasses 
    (:pattern (disjointclasses (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:AllDisjointClasses)
  (triple (:blank ?x) !owl:members (t (seq (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)))))

(defrdfm disjointunion 
    (:pattern (disjointunion ?class (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)) :case :sequence)
  (triple (t ?class) !owl:disjointUnionOf (t (seq (:subscript ?class-expression 1) :elipsis (:subscript ?class-expression ?n)))))

;; manual reversal of the next two because the pattern matcher isn't good enough and so needs to have it's priorities right.
(defrdfm subobjectpropertyof 
    (:pattern (subobjectpropertyof (objectpropertychain (:subscript ?object-property-expression 1) :elipsis (:subscript ?object-property-expression ?n)) ?object-property-expression) :case :sequence)
  (triple (t ?object-property-expression) !owl:propertyChainAxiom (t (seq (:subscript ?object-property-expression 1) :elipsis (:subscript ?object-property-expression ?n)))))

(defrdfm subobjectpropertyof 
    (:pattern (subobjectpropertyof (:subscript ?object-property-expression 1) (:subscript ?object-property-expression 2)) :case :named-variable)
  (triple (t (:subscript ?object-property-expression 1)) !rdfs:subPropertyOf (t (:subscript ?object-property-expression 2))))

(defrdfm equivalentobjectproperties 
    (:pattern (equivalentobjectproperties (:subscript ?object-property-expression 1) :elipsis (:subscript ?object-property-expression ?n)) :case :foreach)
  (triple (t (:subscript ?object-property-expression 1)) !owl:equivalentProperty (t (:subscript ?object-property-expression 2)))
  :elipsis
  (triple (t (:subscript ?object-property-expression ?n-1)) !owl:equivalentProperty (t (:subscript ?object-property-expression ?n))))

(defrdfm disjointobjectproperties 
    (:pattern (disjointobjectproperties (:subscript ?object-property-expression 1) (:subscript ?object-property-expression 2)) :case :named-variable)
  (triple (t (:subscript ?object-property-expression 1)) !owl:propertyDisjointWith (t (:subscript ?object-property-expression 2))))

(defrdfm disjointobjectproperties 
    (:pattern (disjointobjectproperties (:subscript ?object-property-expression 1) :elipsis (:subscript ?object-property-expression ?n)) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:AllDisjointProperties)
  (triple (:blank ?x) !owl:members (t (seq (:subscript ?object-property-expression 1) :elipsis (:subscript ?object-property-expression ?n)))))

(defrdfm objectpropertydomain 
    (:pattern (objectpropertydomain ?object-property-expression ?class-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdfs:domain (t ?class-expression)))

(defrdfm objectpropertyrange 
    (:pattern (objectpropertyrange ?object-property-expression ?class-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdfs:range (t ?class-expression)))

(defrdfm inverseobjectproperties 
    (:pattern (inverseobjectproperties (:subscript ?object-property-expression 1) (:subscript ?object-property-expression 2)) :case :named-variable)
  (triple (t (:subscript ?object-property-expression 1)) !owl:inverseOf (t (:subscript ?object-property-expression 2))))

(defrdfm functionalobjectproperty 
    (:pattern (functionalobjectproperty ?object-property-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdf:type !owl:FunctionalProperty))

(defrdfm inversefunctionalobjectproperty 
    (:pattern (inversefunctionalobjectproperty ?object-property-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdf:type !owl:InverseFunctionalProperty))

(defrdfm reflexiveobjectproperty 
    (:pattern (reflexiveobjectproperty ?object-property-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdf:type !owl:ReflexiveProperty))

(defrdfm irreflexiveobjectproperty 
    (:pattern (irreflexiveobjectproperty ?object-property-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdf:type !owl:IrreflexiveProperty))

(defrdfm symmetricobjectproperty 
    (:pattern (symmetricobjectproperty ?object-property-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdf:type !owl:SymmetricProperty))

(defrdfm asymmetricobjectproperty 
    (:pattern (asymmetricobjectproperty ?object-property-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdf:type !owl:AsymmetricProperty))

(defrdfm transitiveobjectproperty 
    (:pattern (transitiveobjectproperty ?object-property-expression) :case :subscript-free)
  (triple (t ?object-property-expression) !rdf:type !owl:TransitiveProperty))

(defrdfm subdatapropertyof 
    (:pattern (subdatapropertyof (:subscript ?data-property-expression 1) (:subscript ?data-property-expression 2)) :case :named-variable)
  (triple (t (:subscript ?data-property-expression 1)) !rdfs:subPropertyOf (t (:subscript ?data-property-expression 2))))

(defrdfm equivalentdataproperties 
    (:pattern (equivalentdataproperties (:subscript ?data-property-expression 1) :elipsis (:subscript ?data-property-expression ?n)) :case :foreach)
  (triple (t (:subscript ?data-property-expression 1)) !owl:equivalentProperty (t (:subscript ?data-property-expression 2)))
  :elipsis
  (triple (t (:subscript ?data-property-expression ?n-1)) !owl:equivalentProperty (t (:subscript ?data-property-expression ?n))))

(defrdfm disjointdataproperties 
    (:pattern (disjointdataproperties (:subscript ?data-property-expression 1) (:subscript ?data-property-expression 2)) :case :named-variable)
  (triple (t (:subscript ?data-property-expression 1)) !owl:propertyDisjointWith (t (:subscript ?data-property-expression 2))))

(defrdfm disjointdataproperties 
    (:pattern (disjointdataproperties (:subscript ?data-property-expression 1) :elipsis (:subscript ?data-property-expression ?n)) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:AllDisjointProperties)
  (triple (:blank ?x) !owl:members (t (seq (:subscript ?data-property-expression 1) :elipsis (:subscript ?data-property-expression ?n)))))

(defrdfm datapropertydomain 
    (:pattern (datapropertydomain ?data-property-expression ?class-expression) :case :subscript-free)
  (triple (t ?data-property-expression) !rdfs:domain (t ?class-expression)))

(defrdfm datapropertyrange 
    (:pattern (datapropertyrange ?data-property-expression ?data-range) :case :subscript-free)
  (triple (t ?data-property-expression) !rdfs:range (t ?data-range)))

(defrdfm functionaldataproperty 
    (:pattern (functionaldataproperty ?data-property-expression) :case :subscript-free)
  (triple (t ?data-property-expression) !rdf:type !owl:FunctionalProperty))

(defrdfm datatypedefinition 
    (:pattern (datatypedefinition ?datatype ?data-range) :case :subscript-free)
  (triple (t ?datatype) !owl:equivalentClass (t ?data-range)))

;; Not automatically translated - overridden by manual translation
(defrdfm haskey
         (:pattern
          (haskey ?class-expression ((?* ?multiple-?object-property-expression))
		  ((?* ?multiple-?data-property-expression)))
          :case :subscript-free)
   (triple (t ?class-expression)
                 (make-uri nil "owl:hasKey")
                 (t (system::backq-cons 'seq
                                        (system::backq-append ?multiple-?object-property-expression
                                                              ?multiple-?data-property-expression)))))
(defrdfm sameindividual 
    (:pattern (sameindividual (:subscript ?individual 1) :elipsis (:subscript ?individual ?n)) :case :foreach)
  (triple (t (:subscript ?individual 1)) !owl:sameAs (t (:subscript ?individual 2)))
  :elipsis
  (triple (t (:subscript ?individual ?n-1)) !owl:sameAs (t (:subscript ?individual ?n))))

(defrdfm differentindividuals 
    (:pattern (differentindividuals (:subscript ?individual 1) (:subscript ?individual 2)) :case :named-variable)
  (triple (t (:subscript ?individual 1)) !owl:differentFrom (t (:subscript ?individual 2))))

(defrdfm differentindividuals 
    (:pattern (differentindividuals (:subscript ?individual 1) :elipsis (:subscript ?individual ?n)) :case :sequence)
  (triple (:blank ?x) !rdf:type !owl:AllDifferent)
  (triple (:blank ?x) !owl:members (t (seq (:subscript ?individual 1) :elipsis (:subscript ?individual ?n)))))

(defrdfm classassertion 
    (:pattern (classassertion ?class-expression ?individual) :case :subscript-free)
  (triple (t ?individual) !rdf:type (t ?class-expression)))

;; manual reversal of the next two because the pattern matcher isn't good enough and so needs to have it's priorities right.
(defrdfm objectpropertyassertion 
    (:pattern (objectpropertyassertion (objectinverseof ?object-property) (:subscript ?individual 1) (:subscript ?individual 2)) :case :named-variable)
  (triple (t (:subscript ?individual 2)) (t ?object-property) (t (:subscript ?individual 1))))

(defrdfm objectpropertyassertion 
    (:pattern (objectpropertyassertion ?object-property (:subscript ?individual 1) (:subscript ?individual 2)) :case :named-variable)
  (triple (t (:subscript ?individual 1)) (t ?object-property) (t (:subscript ?individual 2))))

(defrdfm negativeobjectpropertyassertion 
    (:pattern (negativeobjectpropertyassertion ?object-property-expression (:subscript ?individual 1) (:subscript ?individual 2)) :case :named-variable)
  (triple (:blank ?x) !rdf:type !owl:NegativePropertyAssertion)
  (triple (:blank ?x) !owl:sourceIndividual (t (:subscript ?individual 1)))
  (triple (:blank ?x) !owl:assertionProperty (t ?object-property-expression))
  (triple (:blank ?x) !owl:targetIndividual (t (:subscript ?individual 2))))

(defrdfm datapropertyassertion 
    (:pattern (datapropertyassertion ?data-property-expression ?individual ?literal) :case :subscript-free)
  (triple (t ?individual) (t ?data-property-expression) (t ?literal)))

(defrdfm negativedatapropertyassertion 
    (:pattern (negativedatapropertyassertion ?data-property-expression ?individual ?literal) :case :subscript-free)
  (triple (:blank ?x) !rdf:type !owl:NegativePropertyAssertion)
  (triple (:blank ?x) !owl:sourceIndividual (t ?individual))
  (triple (:blank ?x) !owl:assertionProperty (t ?data-property-expression))
  (triple (:blank ?x) !owl:targetValue (t ?literal)))

(defrdfm annotationassertion 
    (:pattern (annotationassertion ?annotation-property ?annotation-source ?annotation-value) :case :subscript-free)
  (triple (t ?annotation-source) (t ?annotation-property) (t ?annotation-value)))

(defrdfm subannotationpropertyof 
    (:pattern (subannotationpropertyof (:subscript ?annotation-property 1) (:subscript ?annotation-property 2)) :case :named-variable)
  (triple (t (:subscript ?annotation-property 1)) !rdfs:subPropertyOf (t (:subscript ?annotation-property 2))))

(defrdfm annotationpropertydomain 
    (:pattern (annotationpropertydomain ?annotation-property ?iri) :case :subscript-free)
  (triple (t ?annotation-property) !rdfs:domain (t ?iri)))

(defrdfm annotationpropertyrange 
    (:pattern (annotationpropertyrange ?annotation-property ?iri) :case :subscript-free)
  (triple (t ?annotation-property) !rdfs:range (t ?iri)))
