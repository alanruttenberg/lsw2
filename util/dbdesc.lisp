;; Copyright Â© 2013 Alan Ruttenberg and SUNY at Buffalo All Rights Reserved.

;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions
;; are met:

;; 1. Redistributions of source code must retain the above copyright
;; notice, this list of conditions and the following disclaimer.

;; 2. Redistributions in binary form must reproduce the above
;; copyright notice, this list of conditions and the following
;; disclaimer in the documentation and/or other materials provided
;; with the distribution.

;; 3. The name of the author may not be used to endorse or promote
;; products derived from this software without specific prior written
;; permission.

;; THIS SOFTWARE IS PROVIDED BY Alan Ruttenberg "AS IS" AND ANY EXPRESS OR
;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
;; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

;; Parse and query the XML description generated by the database schema extraction tool dbdesc
;; http://www.dbdesc.com

;; Read in XML, parse to sexps, and save in a file for next time. If
;; the sexps are available load them instead of parsing the XML again

(defun read-dbdesc-xml (xml-path &optional lisp-path &aux parsed)
  (unless lisp-path (setq lisp-path (merge-pathnames (make-pathname :type "lisp") xml-path)))
  (if (probe-file lisp-path)
      (setq parsed (with-open-file (f lisp-path) (read f)))
      (progn
	(setq parsed
	      (with-open-file (f xml-path :direction :input) 
		(read-char f) (read-char f)(read-char f) (xmls:parse f)))
	(write-dbdesc-lisp parsed lisp-path)))
  parsed)

;; save the sexps version

(defun write-dbdesc-lisp (parsed-dbdesc xml-path &optional lisp-path)
  (unless lisp-path (setq lisp-path (merge-pathnames (make-pathname :type "lisp") xml-path)))
  (with-open-file (f lisp-path :if-does-not-exist :create :direction :output :if-exists :supersede :external-format :utf8)
    (print parsed-dbdesc f)
    ))

;; retrieve a list of all the tables by walking all elements and retrieving the
;; values of the TABLE_NAME elements.

(defun-memo dbdesc-tables (dbdesc)
  (let ((them nil))
    (map-elements dbdesc
		  (lambda(node)
		    (when (consp node)
		      (let ((element-tag (if (consp (car node)) (caar node) (car node))))
			(when (string= "TABLE_NAME" element-tag)
			  (pushnew (third node) them :test 'string=))))))
    them))

;; retrieve a list of tables whose names match regex

(defun dbdesc-tables-matching (dbdesc regex)
  (remove-if-not (lambda(el)  (#"matches" el regex)) (dbdesc-tables dbdesc)))

(defun-memo dbdesc-table-to-primary-key (dbdesc)
  (let ((hash (make-hash-table :test 'equal)))
    (map-elements dbdesc
		  (lambda(node)
		    (when (consp node)
		      (let ((element-tag (if (consp (car node)) (caar node) (car node))))
			(when (string= "Table" element-tag)
			  (let* ((table-name (third (find-element-with-tag node "TABLE_NAME")))
				 (pks nil)
				 (uniques nil))
			    (loop for field in (find-elements-with-tag node "FIELD")
			       for ftn = (third (find-element-with-tag field "TABLE_NAME"))

			       ;; either look for a field with datatype uniqueid
				 
			       when (and (equal ftn table-name)
					 (equal (third (find-element-with-tag field "DATA_TYPE")) "uniqueid"))
			       do (push (third (find-element-with-tag node "COLUMN_NAME")) uniques)

			       ;; or look for primary keys. Note, however that if a table has a composite
			       ;; primary key you will get more than one column

			       when (and (equal ftn table-name)
					 (equal (third (third (setq pknode (find-element-with-tag field "PrimaryKey")))) table-name)
					 (equal (third (find-element-with-tag pknode "COLUMN_NAME"))
						(third (find-element-with-tag field "COLUMN_NAME"))))
			       do (push (third (find-element-with-tag pknode "COLUMN_NAME")) pks)
			       finally (when (or uniques pks)
					 (setf (gethash table-name hash) (remove-duplicates (or uniques pks) :test 'equal))))
			    ))))))
    hash))

(defun-memo dbdesc-tables-without-unique-key (dbdesc)
  (let ((with nil))
    (maphash  (lambda(k v) (push k with)) (dbdesc-table-to-primary-key dbdesc))
    (set-difference (dbdesc-tables dbdesc) with :test 'equal)))

(defun dbdesc-table-xml (dbdesc table)
  (find table (find-immediate-children-with-tag dbdesc "TABLE") :key (lambda(e) (third (third e))) :test 'equal))

;; this uses the dbdesc to find the primary key and probably some oracle specific functions that should be conditionalized.
(defun sample-of-rows (table connection dbdesc &optional howmany)
  (let ((primary-key (dbdesc-table-primary-key dbdesc table)))
    (sql-query (list "select  * from ~a where ~a in (select top ~a ~a from ~a order by newid())" 
		     table primary-key (or howmany 5) primary-key table) connection :print t)))
