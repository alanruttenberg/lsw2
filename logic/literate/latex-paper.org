# -*- Mode: POLY-ORG;  -*- ---
#+PROPERTY: literate-lang lisp
#+PROPERTY: literate-load yes
#+header: :package logic :results :none

#+BEGIN_SRC lisp
(in-package :logic)
#+END_SRC


* Introduction

I write papers in org mode, with generation to latex. The papers involve both
written prose and generated content. This code is intended to help orchestrate
how the two types of content work together. In the text below I'll /lisp/ means
Common Lisp, and /elisp/ means Emacs Lisp.

** Previous implementation

This is a re-implementation of exploratory code to support typesetting of
formulas, proofs, class and relation names. 

The specific functionalities were:

1. To allow a code in a lisp source block to specify a formula, either in LSW syntax, or by spec
   and to have the results of the source block be latex code that nicely typeset the formula, which 
   was included in line.

2. In other source blocks, specify a proof attempt, with assumptions and goal named by
   reference to formulas in the file. Executing the source block would generate some
   text for the proof indicating success or failure, as well as generate supplementary materials
   such as the input and output files for the prover.

3. To, given a list of relation and class names as an elisp variable, arrange 
   for mentions of them in the body of the text to be typeset. This was implemented
   as a filter operating in the generation of latex code.

Unfortunately, the implementation landed up creating a tangle of dependencies
among the various artifacts used, which included latex macros in an included
file, support packages from the latex distribution, lisp code that generated
latex that relied on those, elisp specifications, elisp support code, and shell
scripts.

Although lisp-generated code depended on the packages and macros, specifying
those macros and packages and including them wasn't the responsibility of lisp.
Instead these were define in included files and latex preambles. 
Support files were expected to be in known places relative to the main paper.org.
It became difficult to ensure that the parts were coordinated, particularly 
in the face of evolving both the lisp and latex code and because of slightly
different needs across projects.

For typesetting class and relation names, I first used org macros to surround each name, 
with the macros generating latex calls to macros. However, it was too easy to forget
to do that consistently, leading to some names being typeset, and others not. 
A second implementation let you write the names in text without (for the most part) 
worrying about the typesetting. Then, during the transformation of the org file
to latex, a step was inserted that did search and replace of names specified
in two elisp variables, one for relations, and one for classes. 

Even this is mildly problematic - the relevant relations and classes can be computed
from the theory - the set of formulas under discussion. Having to specify them 
indpendently introduced potential errors.

* Rethinking the strategy

In order to enable coordination of the emacs and lisp sides, a first goal is to
make it so that when executing a command in emacs it is equally reasonable to
implement the method in elisp or commonlisp. The lisp side should be able to
understand what's in the emacs buffer. We want to be able to achieve the
functions in the previous implementations as well as others, such as checking
that the paper includes all the formulas in a theory (spec) or keeping
cross-references organized.

** Requirements

1. The paper should be editable as well as be able to be typeset without lisp
   running, as long as I don't execute a command that requires lisp.  That means
   that any contributions of lisp-generated contents should be written to static
   files, available when working without lisp.

2. If some of the work is computationally expensive, it shouldn't have to be done
   unless necessary. For example, running a proof can be time consuming. The
   request for proof is typically done when a source block is executed by babel.
   However, we don't want to worry about when or how many times we choose to
   evaluate a source block.  This is accomplished by having a cache of proof
   content keyed to the md5 of the assumptions and goals, and avoiding redoing work
   for proofs already in the cache. It's not sufficient to only have an in-memory
   cache as that gets lost when lisp restarts.

3. It shouldn't be onerous to initialize the lisp side when editing a paper. Ideally
   it gets done when the paper opens, automatically. However, a paper might have
   specific needs for systems to be loaded, so we need to be able to specify those
   requirements in the paper and have them passed to lisp.

4. There should be a clear division of labor between what's needed and expected on
   the emacs side vs the lisp side. One area of concern is latex preambles and
   support filess.   Each side should do what it does best. On the emacs side, babel manages source
   blocks well, and babel-execute-src-block manages how results of the evaluation
   impact the paper. Oppose this to using slime-eval-defun, which doesn't know
   about results.  While it would be possible to have the lisp side manage results
   by instructing elisp what to insert and where, that would be re-implementing
   what babel does well. 

Something else done on the elisp side is the recognizing of class and relation
terms and then having latex set them without me having to bother with the
details. The initial implementation uses a couple of elisp variables to list
what relations and classes are in the text, and then uses that list in a filter 
used when the latex is generated, insertng the extra latex code at that time.
OTOH, the elisp variable have content that the lisp side knows more about, as 
it keeps track of the spec the paper is writing about. The relations and classes
are easily derivable from the spec, and so lisp should set the elements in the 
elisp variables.

** Implementation strategy

For each paper being edited, there will be an instance of the class ~latex-paper~ (or subclass) that corresponds to it.

The lisp latex-paper instance doesn't know how to do everything. For 
in a logic paper, the typesetting of formulas is delegated to the ~latex-logic-generator~.

Virtually all latex support is generated on the lisp side. No defs.tex. latex support
means packages, settings, macros. The only case I'm considered for the Emacs side is
the typesetting of relations and classes, which uses a macro defined locally.

Assume we are working in a folder with the org file(s) at root. 
Lisp will create subdirectories with related content or caches.

** File organization
There will be a folder where all the files for the paper go. Files include, for
example, the org-mode , any nonstandard latex styles or macros, supplementary
materials such as figures, latex formulas, proof records, etc.
We'll expect there to be a main org file for the paper, a parallel tex file,
and possibly some scripts.
* Implementation
** Communicating with Emacs
Emacs communicates with Lisp using slime using slime-eval.

#+begin_src lisp load no
(slime-eval SEXP &optional PACKAGE)
#+end_src

Lisp communicates with Emacs using ~swank::eval-in-emacs~. Swank typically loads
after LSW does, so don't name it directly so the reader doesn't barf.

#+begin_src lisp
(defun eval-in-emacs (form)
  (funcall (intern "EVAL-IN-EMACS" 'swank) form))
#+end_src

Typically we will want to make sure that when we're evaluating in emacs we do so
within the right buffer. ~eval-in-emacs-buffer~ does that. If serial is passed
then it evaluates in the buffer with paper-serial = serial. Otherwise it
evaluates in the top buffer. If attempting to evaluate using a serial that 
doesn't correspond to a buffer, either error, or :if-not-found is passed,
return that.

#+begin_src lisp
(defun eval-in-emacs-buffer (form &key serial if-not-found)
  (let ((result
	  (eval-in-emacs
	   (if serial
	       `(block found
		  (mapcar (lambda(b)
			    (with-current-buffer b
			      (when (equal (eval 'paper-serial)  ,serial)
				(return-from found
				  ,form))))
			  (buffer-list))
		  :not-found)
	       `(with-current-buffer (car (buffer-list (selected-frame)))
		  ,form)))))
    (or (and (eq result :not-found) if-not-found)
	(assert (not (eq result :not-found))
		() "Couldn't find buffer with serial ~a" serial)
	result)))

(defun emacs-buffer-name (&optional serial)
  (eval-in-emacs-buffer '(buffer-name) :serial serial))

(defun emacs-buffer-contents (&optional serial)
  (eval-in-emacs-buffer
   '(buffer-substring-no-properties
     (point-min) (point-max))
   :serial serial))

;(emacs-buffer-name 345249022)
;(eval-in-emacs-buffer 'buffer-file-name :serial 345249022)
;(eval-in-emacs-buffer 'buffer-file-name :serial 1)
#+end_src

#+name: example-top-buffer-file
#+begin_src lisp :results org :package logic :load no
  (pathname-name (eval-in-emacs-buffer 'buffer-file-name))
#+end_src

#+RESULTS: example-top-buffer-file
#+BEGIN_SRC org
"paper-support" 
#+END_SRC

** Connecting a buffer in Emacs to an object in Lisp

We will use /serial number/ to mean a unique identifier for a buffer. On the Emacs 
side we'll set a buffer-local variable ~paper-serial~ to hold the serial number.
On the Emacs side we'll have one or more hashes mapping, at least, serial number 
to Lisp object representing the buffer.

Initiation will be done from the Emacs side. In a a source block call ~register-paper~. 
~Register-paper~ takes a class name as its first argument, and then a list of keyword arguments
used to initialize the instance.

When register-paper runs on the lisp side it will assume that the top emacs buffer is the 
caller. It will then checks if the buffer local ~paper-serial~ is bound.  If it isn't
then it's the first time Lisp has seen the buffer. The hash mapping buffer serial number to 
instance is accessed using ~to-paper-instance~, and set using ~set-paper-instance~. 

#+begin_src lisp
(defvar *serial-to-paper-instance* (make-hash-table :test 'equalp))
    
(defun get-paper-instance (serial)
  (gethash serial *serial-to-paper-instance*))

(defun set-paper-instance (serial instance)
  (setf (gethash serial *serial-to-paper-instance*) instance))

(defun get-top-buffer-paper-instance ()
  (get-paper-instance (eval-in-emacs-buffer 'paper-serial)))

#+end_src

To allocated a unique id we first try to make one based on the file name and buffer name. 

 generate a large random numbers. Just to be sure it is unique 
we check if there's already an instance mapped to it, and if so, try again.

#+begin_src lisp
(defun generate-paper-serial ()
  (let ((maybe-stable (eval-in-emacs-buffer '(ignore-errors (list buffer-file-name (buffer-name))))))
    (if  (some 'identity maybe-stable)
      (destructuring-bind (file-name buffer-name) maybe-stable
	(setq buffer-name (#"replaceFirst" buffer-name "\\[lisp\\]" ""))
	(md5 (concatenate 'string file-name "-" buffer-name)))
      (loop for try = (random most-positive-fixnum)
	    until (not (get-paper-instance try))
	    finally (return try)))))
#+end_src

As a sanity check, when registering, make sure the buffer, which is the top
buffer, is named as an org mode buffer, and is in org-mode or poly-org-mode.

#+begin_src lisp
(defun check-registering-buffer-is-org ()
  (and (#"matches" (eval-in-emacs-buffer '(buffer-name)) ".*\\.org(\\[.*\\])$")
       (eval-in-emacs-buffer `(or
			       (and (boundp 'poly-org-mode) poly-org-mode)
			       (and (boundp 'org-mode) org-mode)))))
#+end_src

Finally the implementation of ~register-paper~. register-paper is expected to 
be called from a lisp src block in your org file. At the time that's done, 
your org file is the active buffer. First we check that the buffer is 
an org file. 

Then we check whether the buffer already has a serial number. If it does,
then all we do is use the passed initargs to (re)set the corresponding slots
on the paper instance. Otherwise we call make-instance to create an instance
of the class, initializing it using initargs, and save it in our table 
mapping serial numbers to instances.

#+begin_src lisp
(defun register-paper (class &rest initargs &key force &allow-other-keys)
  (when (keywordp class)
    (setq class (intern (string class) 'logic)))
  (assert (check-registering-buffer-is-org) () "Trying to register a paper from a buffer that isn't in org mode")
  (let ((serial (eval-in-emacs-buffer '(if (boundp 'paper-serial) paper-serial))))
    (if (and serial (get-paper-instance serial)
             (eq class (class-name (class-of (get-paper-instance serial))))
             (not force))
        (apply 'initialize-instance (get-paper-instance serial) initargs)
	(let ((instance (apply 'make-instance class :paper-folder
                               (make-pathname :directory (pathname-directory (eval-in-emacs-buffer 'buffer-file-name)))
                               initargs)))
	  (unless serial		; we might have restarted slime
	    (eval-in-emacs-buffer '(make-variable-buffer-local 'paper-serial))
	    (setq serial (generate-paper-serial))
	    (eval-in-emacs-buffer `(setq paper-serial ,serial)))
	  (set-paper-instance serial instance)))))
#+end_src    


* The latex-paper class

This class represents a paper. Associated information includes a list of
things that might have something to say about the latex content.  Each
latex-generator is asked to contribute packages, fonts (also
packages + macros), macros, possibly directives to be included after
~\begin{document}~

#+BEGIN_SRC lisp
(defclass latex-paper ()
  ((latex-generators :accessor latex-generators :initform nil :initarg :latex-generators)
   (document-class :accessor document-class :initform "article" :initarg :document-class )
   (hmargin :accessor hmargin :initform ".75in" :initarg :hmargin )
   (vmargin :accessor vmargin :initform "{.75in,.25in}" :initarg :vmargin )
   (input-filename :accessor input-filename :initform nil :initarg :input-filename )
   (latex-packages :accessor latex-packages :initform nil :initarg :latex-packages )
   (latex-fonts :accessor latex-fonts :initform nil :initarg :latex-fonts )
   (latex-preamble :accessor latex-preamble :initform nil :initarg :latex-preamble)
   (latex-after-document-begins :accessor latex-after-document-begins :initform nil :initarg :latex-after-document-begins )
   (paper-folder :accessor paper-folder :initform nil :initarg :paper-folder)
   (license :accessor license :initform nil :initarg :license)
   (buffer-serial-number :accessor buffer-serial-number)
   (depends-on-systems :accessor depends-on-systems :initform nil :initarg :depends-on-systems)
   (depends-on-files :accessor depends-on-files :initform nil :initarg :depends-on-files)
   (satisfied-dependencies :accessor satisfied-dependencies :initform nil :initarg :satisfied-dependencies)
   ))
#+end_src

** Dependencies

When registering a file we want to be able to specify that certain systems or files should be loaded.

#+begin_src lisp
(defmethod ensure-paper-lisp-requirements-loaded ((p latex-paper) &optional force)
  (loop for system in (depends-on-systems p)
        unless (or force (not (member system (satisfied-dependencies p))))
          do (asdf::load-system system)
             (pushnew system (satisfied-dependencies p)))
  (loop for file in (depends-on-files p)
        unless (or force (not (member (truename file) (satisfied-dependencies p))))
          do (load file)
             (pushnew file (satisfied-dependencies p))))
#+end_src

** Initialization

The initalization method adds self as the first generator, and we load any requirements.

#+BEGIN_SRC lisp
(defmethod initialize-instance ((p latex-paper) &rest args &key &allow-other-keys)
  (declare (ignore args))
  (call-next-method)
  (push p (latex-generators p))
  (ensure-paper-lisp-requirements-loaded p)
  (setq cl-user::* p)
  )
#+END_SRC
   
** Generators

Generators are classes or instances responsible for creating, as source block results, latex source
that will be used in the paper. The prototypical generator is the latex-logic-generator, which accepts 
formulas and generates latex to typeset them in a presentable manner. 

Let's take the latex-logic-generator as an example. The generator is called to render each formula. However 
the latex that is generated has dependencies: it may use different fonts, or have dependencies on other packages.
We don't want to have to worry about these for every formula, so we have an API to ask it (the class, in this case)
about dependencies, and we include the class as one of the latex-generators for the paper.

Generators can be anything that has the required methods. For classes I've been using the class 
name, defining the methods as eql specialized. The paper instance is typically a generator as well.

*** Generator method: latex-packages

Returns a list of package names and optionally arguments for the
package. A package is referenced either as a string naming it, or as a
list with the first element being the package name and subsequent elements
being the strings defining options. If there is more than one option they
are joined with ",". For example

#+begin_src lisp :load no
(defmethod latex-packages ((c (eql 'latex-logic-generator)))
  '("amsmath" "flexisym" "xcolor" "tabularx" "trimclip"))
#+end_src

#+begin_example
#+begin_latex
\include{amsmath}
\include{flexisym}
\include{xcolor}
\include{tabularx}
\include{trimclip}
#+end_latex
#+end_example

*** Generator method: latex-fonts

Returns a list with two elements. The first element is a list of any
packages that need to be included, in the same format as
latex-packages. The second element is a list of any macros that
need to be defined to use them in specific contexts, for example in math
mode, or when typesetting formulas.

*** Generator method: latex-preamble

Each element of this list is either a string or a list of strings comprising one macro, command, environment, 
or other directive. For example, the logic generator needs a custom column type to be used inside ~\tabularx~,
so we would include that definition as one of the preamble strings. The strings are all included in the 
latex before ~\begin{document}~.

*** Generator method: document-class 
Used as the argument(s) for ~\documentclass~. e.g. "article". Either a string, or a list with the
first element being the document class and the second being the options.

*** Generator method: latex-after-document-begins
Some material may need to be included after ~\begin{document}~. This method should write the
~\begin{document}~ as well as any latex needed.  Adding \end{document} is the responsibility 
of the author.

** The other slots

*** margin
  if given then a length, like "1in". TODO allow specification of all margins. Default "1in"

*** input-filename
The method prepare-latex-to-include generates a tex file to include. This is relative to the paper folder.

*** latex-packages, latex-fonts, latex-preamble
  Described above. If supplied, packages and macros are added to those from other generators
  The fonts behave differently - if supplied they override the other generators.

Then 'latex-logic-generator is one of the elements of latex-generators. This instance of latex-paper
would typically also be a generator, as we'll see below. 

** Latex-paper methods

*** prepare-latex-to-include

Generate a latex file which can either be the start of a standalone document, or \input into another one.
The method collects packages, macros, and the fonts from the first generator that supplies it.
It then writes out fonts, then packages, then macros. If latex-after-document-begins is passed it also writes \begin{document} and then whatever latex-after-document-begins is.

#+BEGIN_SRC lisp
(defmethod prepare-latex-to-include ((p latex-paper))
  (with-open-file (f (merge-pathnames (input-filename p) (paper-folder p)) :direction :output :if-exists :supersede)
    (when (document-class p) (format f "\\documentclass~a{~a}~%" 
				     (if (stringp (document-class p))
					 ""
					 (format nil "[~a]" (second (document-class p))))
				     (if (stringp (document-class p)) (document-class p))))
    (when (or (hmargin p) (vmargin p))
      (format f "\\usepackage[hmargin=~a,vmargin=~a]{geometry}~%" (hmargin p) (vmargin p)))
    ;; packages written first, then fonts, then macros
    (loop for generator in (latex-generators p)
	  for (fonts font-macros) = (unless (or fonts macros) (latex-fonts generator))
	  for use-fonts = (or use-fonts fonts)
	  append (latex-packages generator) into packages
	  append font-macros into macros
	  append (latex-preamble generator) into macros
	  finally
	     (progn
;	       (inspect p)
	       (format f  "~{~a~%~}" use-fonts)
	       (format f "~{\\usepackage{~a}~%~}" packages)
	       (format f  "~{~a~%~}" 
		       (mapcan (lambda(e) (if (stringp e) (list e) (copy-list e))) macros))))
    (when (latex-after-document-begins p)
      (format f "\\begin{document}~%")
      (format f  "~{~a~%~}" 
      (mapcan (lambda(e) (if (stringp e) (list e) (copy-list e))) (latex-after-document-begins p))))))
#+END_SRC


